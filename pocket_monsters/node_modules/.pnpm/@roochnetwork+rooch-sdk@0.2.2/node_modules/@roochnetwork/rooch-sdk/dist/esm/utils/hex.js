function isHex(input) {
  if (typeof input === "string") {
    return /^(0x|0X)?[a-fA-F0-9]+$/.test(input) && input.length % 2 === 0;
  } else {
    for (let i = 0; i < input.length; i++) {
      const byte = input[i];
      if (!(byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102)) {
        return false;
      }
    }
    return true;
  }
}
function getHexByteLength(input) {
  return /^(0x|0X)/.test(input) ? (input.length - 2) / 2 : input.length / 2;
}
function normalizeHex(input) {
  return input.startsWith("0x") ? input.slice(2) : input;
}
function fromHEX(input) {
  const normalized = normalizeHex(input);
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
  const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
  return Uint8Array.from(intArr);
}
const u8a = (a) => a instanceof Uint8Array;
const hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function toHEX(input) {
  if (!u8a(input))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < input.length; i++) {
    hex += hexes[input[i]];
  }
  return hex;
}
export {
  fromHEX,
  getHexByteLength,
  isHex,
  normalizeHex,
  toHEX
};
//# sourceMappingURL=hex.js.map
