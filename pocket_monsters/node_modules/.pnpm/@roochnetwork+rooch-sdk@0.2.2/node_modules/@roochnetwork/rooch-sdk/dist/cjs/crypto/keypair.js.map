{
  "version": 3,
  "sources": ["../../../src/crypto/keypair.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bech32 } from 'bech32'\n\nimport { Signer } from './signer.js'\nimport type { SignatureScheme } from './signatureScheme.js'\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from './signatureScheme.js'\n\nexport const PRIVATE_KEY_SIZE = 32\nexport const LEGACY_PRIVATE_KEY_SIZE = 64\n\nexport const ROOCH_SECRET_KEY_PREFIX = 'roochsecretkey'\n\nexport type ParsedKeypair = {\n  schema: SignatureScheme\n  secretKey: Uint8Array\n}\n\nexport abstract class Keypair extends Signer {\n  /**\n   * This returns the Bech32 secret key string for this keypair.\n   */\n  abstract getSecretKey(): string\n}\n\n/**\n * This returns an ParsedKeypair object based by validating the\n * 33-byte Bech32 encoded string starting with `roochsecretkey`, and\n * parse out the signature scheme and the private key in bytes.\n */\nexport function decodeRoochSercetKey(value: string): ParsedKeypair {\n  const { prefix, words } = bech32.decode(value)\n  if (prefix !== ROOCH_SECRET_KEY_PREFIX) {\n    throw new Error('invalid private key prefix')\n  }\n  const extendedSecretKey = new Uint8Array(bech32.fromWords(words))\n  const secretKey = extendedSecretKey.slice(1)\n  const signatureScheme =\n    SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME]\n  return {\n    schema: signatureScheme,\n    secretKey: secretKey,\n  }\n}\n\n/**\n * This returns a Bech32 encoded string starting with `roochsecretkey`,\n * encoding 33-byte `flag || bytes` for the given the 32-byte private\n * key and its signature scheme.\n */\nexport function encodeRoochSercetKey(bytes: Uint8Array, scheme: SignatureScheme): string {\n  if (bytes.length !== PRIVATE_KEY_SIZE) {\n    throw new Error('Invalid bytes length')\n  }\n  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme]\n  const privKeyBytes = new Uint8Array(bytes.length + 1)\n  privKeyBytes.set([flag])\n  privKeyBytes.set(bytes, 1)\n  return bech32.encode(ROOCH_SECRET_KEY_PREFIX, bech32.toWords(privKeyBytes))\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,oBAAuB;AAEvB,oBAAuB;AAEvB,6BAAmE;AAE5D,MAAM,mBAAmB;AACzB,MAAM,0BAA0B;AAEhC,MAAM,0BAA0B;AAOhC,MAAe,gBAAgB,qBAAO;AAK7C;AAOO,SAAS,qBAAqB,OAA8B;AACjE,QAAM,EAAE,QAAQ,MAAM,IAAI,qBAAO,OAAO,KAAK;AAC7C,MAAI,WAAW,yBAAyB;AACtC,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACA,QAAM,oBAAoB,IAAI,WAAW,qBAAO,UAAU,KAAK,CAAC;AAChE,QAAM,YAAY,kBAAkB,MAAM,CAAC;AAC3C,QAAM,kBACJ,gDAAyB,kBAAkB,CAAC,CAA0C;AACxF,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,EACF;AACF;AAOO,SAAS,qBAAqB,OAAmB,QAAiC;AACvF,MAAI,MAAM,WAAW,kBAAkB;AACrC,UAAM,IAAI,MAAM,sBAAsB;AAAA,EACxC;AACA,QAAM,OAAO,gDAAyB,MAAM;AAC5C,QAAM,eAAe,IAAI,WAAW,MAAM,SAAS,CAAC;AACpD,eAAa,IAAI,CAAC,IAAI,CAAC;AACvB,eAAa,IAAI,OAAO,CAAC;AACzB,SAAO,qBAAO,OAAO,yBAAyB,qBAAO,QAAQ,YAAY,CAAC;AAC5E;",
  "names": []
}
