import { bech32, bech32m, createBase58check } from "@scure/base";
import { bcs } from "../bcs/index.js";
import { blake2b, bytes, sha256, validateWitness } from "../utils/index.js";
import { ROOCH_ADDRESS_LENGTH } from "./address.js";
import { RoochAddress } from "./rooch.js";
import { MultiChainID } from "./types.js";
import { ThirdPartyAddress } from "./thirdparty-address.js";
const base58check = createBase58check(sha256);
var BitcoinNetowk = /* @__PURE__ */ ((BitcoinNetowk2) => {
  BitcoinNetowk2[BitcoinNetowk2["Bitcoin"] = 0] = "Bitcoin";
  BitcoinNetowk2[BitcoinNetowk2["Testnet"] = 1] = "Testnet";
  BitcoinNetowk2[BitcoinNetowk2["Signet"] = 2] = "Signet";
  BitcoinNetowk2[BitcoinNetowk2["Regtest"] = 3] = "Regtest";
  return BitcoinNetowk2;
})(BitcoinNetowk || {});
var BitcoinAddressType = /* @__PURE__ */ ((BitcoinAddressType2) => {
  BitcoinAddressType2[BitcoinAddressType2["pkh"] = 0] = "pkh";
  BitcoinAddressType2[BitcoinAddressType2["sh"] = 1] = "sh";
  BitcoinAddressType2[BitcoinAddressType2["wpkh"] = 2] = "wpkh";
  BitcoinAddressType2[BitcoinAddressType2["wsh"] = 2] = "wsh";
  BitcoinAddressType2[BitcoinAddressType2["tr"] = 2] = "tr";
  return BitcoinAddressType2;
})(BitcoinAddressType || {});
class BitcoinAddress extends ThirdPartyAddress {
  constructor(input) {
    super(input);
    let info = this.decode();
    this.bytes = this.wrapAddress(info.type, info.bytes, info.version);
  }
  // static fromBytes(input: Bytes) {
  //   switch (input[0]) {
  //     case BitcoinAddressType.pkh:
  //       return ''
  //     // case: sh = 1,
  //     case BitcoinAddressType.wpkh:
  //       bech32m.encode()
  //   }
  // }
  toBytes() {
    return bytes("utf8", this.rawAddress);
  }
  genMultiChainAddress() {
    return bcs.MultiChainAddress.serialize({
      multiChainId: MultiChainID.Bitcoin,
      rawAddress: this.bytes
    }).toBytes();
  }
  genRoochAddress() {
    if (!this.roochAddress) {
      this.roochAddress = new RoochAddress(blake2b(this.bytes, { dkLen: ROOCH_ADDRESS_LENGTH }));
    }
    return this.roochAddress;
  }
  decode() {
    let input = this.rawAddress;
    if (input.length < 14 || input.length > 74)
      throw new Error("Invalid address length");
    const bech32_network = (() => {
      const sep = input.lastIndexOf("1");
      const bech32Prefix = sep === -1 ? input : input.substring(0, sep);
      switch (bech32Prefix) {
        case "bc":
          return 0 /* Bitcoin */;
        case "tb":
          return 1 /* Testnet */;
        case "bcrt":
          return 3 /* Regtest */;
        default:
          return void 0;
      }
    })();
    if (bech32_network !== void 0) {
      let res;
      try {
        res = bech32.decode(input);
        if (res.words[0] !== 0)
          throw new Error(`bech32: wrong version=${res.words[0]}`);
      } catch (_) {
        res = bech32m.decode(input);
        if (res.words[0] === 0)
          throw new Error(`bech32m: wrong version=${res.words[0]}`);
      }
      const [version, ...program] = res.words;
      const data2 = bech32.fromWords(program);
      validateWitness(version, data2);
      if (version === 0 && data2.length === 32)
        return {
          bytes: data2,
          type: 2 /* wsh */,
          version
        };
      else if (version === 0 && data2.length === 20)
        return {
          bytes: data2,
          type: 2 /* wpkh */,
          version
        };
      else if (version === 1 && data2.length === 32)
        return {
          bytes: data2,
          type: 2 /* tr */,
          version
        };
      else
        throw new Error("Unknown witness program");
    }
    const data = base58check.decode(input);
    if (data.length !== 21)
      throw new Error("Invalid base58 address");
    if (data[0] === 0) {
      return {
        bytes: data.slice(1),
        type: 0 /* pkh */
      };
    } else if (data[0] === 5) {
      return { bytes: data.slice(1), type: 1 /* sh */ };
    }
    throw new Error(`Invalid address prefix=${data[0]}`);
  }
  wrapAddress(type, bytes2, version) {
    const addr = new Uint8Array(bytes2.length + 1 + (version !== void 0 ? 1 : 0));
    addr.set([type]);
    if (version !== void 0) {
      addr.set([version], 1);
      addr.set(bytes2, 2);
    } else {
      addr.set(bytes2, 1);
    }
    return addr;
  }
}
export {
  BitcoinAddress
};
//# sourceMappingURL=bitcoin.js.map
