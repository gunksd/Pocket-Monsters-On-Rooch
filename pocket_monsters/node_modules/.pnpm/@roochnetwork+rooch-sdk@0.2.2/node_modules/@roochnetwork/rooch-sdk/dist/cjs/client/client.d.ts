import { Signer } from '../crypto/index.js';
import { CreateSessionArgs, Session } from '../session/index.js';
import { Address } from '../address/index.js';
import { address, Bytes, u64 } from '../types/index.js';
import { RoochTransport } from './httpTransport.js';
import { CallFunctionArgs, TypeArgs, Transaction } from '../transactions/index.js';
import { AnnotatedFunctionResultView, BalanceInfoView, ExecuteTransactionResponseView, GetBalanceParams, GetStatesParams, ListStatesParams, PaginatedStateKVViews, PaginationArguments, PaginationResult, SessionInfoView, ObjectStateView, QueryUTXOsParams, PaginatedUTXOStateViews, PaginatedInscriptionStateViews, QueryInscriptionsParams, GetBalancesParams, PaginatedBalanceInfoViews, QueryObjectStatesParams, PaginatedIndexerObjectStateViews, QueryTransactionsParams, PaginatedTransactionWithInfoViews, PaginatedEventViews, GetEventsByEventHandleParams, QueryEventsParams, PaginatedIndexerEventViews, ModuleABIView, GetModuleABIParams } from './types/index.js';
/**
 * Configuration options for the RoochClient
 * You must provide either a `url` or a `transport`
 */
export type RoochClientOptions = NetworkOrTransport;
type NetworkOrTransport = {
    url: string;
    transport?: never;
} | {
    transport: RoochTransport;
    url?: never;
};
declare const ROOCH_CLIENT_BRAND: unique symbol;
export declare function isRoochClient(client: unknown): client is RoochClient;
export declare class RoochClient {
    protected chainID: bigint | undefined;
    protected transport: RoochTransport;
    get [ROOCH_CLIENT_BRAND](): boolean;
    /**
     * Establish a connection to a rooch RPC endpoint
     *
     * @param options configuration options for the API Client
     */
    constructor(options: RoochClientOptions);
    getRpcApiVersion(): Promise<string | undefined>;
    getChainId(): Promise<u64>;
    executeViewFunction(input: CallFunctionArgs): Promise<AnnotatedFunctionResultView>;
    signAndExecuteTransaction({ transaction, signer, option, }: {
        transaction: Transaction | Bytes;
        signer: Signer;
        option?: {
            withOutput: boolean;
        };
    }): Promise<ExecuteTransactionResponseView>;
    getStates(params: GetStatesParams): Promise<ObjectStateView[]>;
    listStates(params: ListStatesParams): Promise<PaginatedStateKVViews>;
    getModuleAbi(params: GetModuleABIParams): Promise<ModuleABIView>;
    getEvents(input: GetEventsByEventHandleParams): Promise<PaginatedEventViews>;
    queryEvents(input: QueryEventsParams): Promise<PaginatedIndexerEventViews>;
    queryInscriptions(input: QueryInscriptionsParams): Promise<PaginatedInscriptionStateViews>;
    queryUTXO(input: QueryUTXOsParams): Promise<PaginatedUTXOStateViews>;
    queryObjectStates(input: QueryObjectStatesParams): Promise<PaginatedIndexerObjectStateViews>;
    queryTransactions(input: QueryTransactionsParams): Promise<PaginatedTransactionWithInfoViews>;
    getSequenceNumber(address: string): Promise<u64>;
    /**
     * Get the total coin balance for one coin type, owned by the address owner.
     */
    getBalance(input: GetBalanceParams): Promise<BalanceInfoView>;
    getBalances(input: GetBalancesParams): Promise<PaginatedBalanceInfoViews>;
    transfer(input: {
        signer: Signer;
        recipient: address;
        amount: number | bigint;
        coinType: TypeArgs;
    }): Promise<ExecuteTransactionResponseView>;
    transferObject(input: {
        signer: Signer;
        recipient: address;
        objectId: string;
        objectType: TypeArgs;
    }): Promise<ExecuteTransactionResponseView>;
    resolveBTCAddress(roochAddress: string | Address): Promise<AnnotatedFunctionResultView>;
    createSession({ sessionArgs, signer }: {
        sessionArgs: CreateSessionArgs;
        signer: Signer;
    }): Promise<Session>;
    removeSession({ authKey, signer }: {
        authKey: string;
        signer: Signer;
    }): Promise<boolean>;
    sessionIsExpired({ address, authKey, }: {
        address: address;
        authKey: string;
    }): Promise<boolean>;
    getSessionKeys({ address, limit, cursor, }: {
        address: address;
    } & PaginationArguments<string>): Promise<PaginationResult<string, SessionInfoView>>;
}
export {};
