"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var client_exports = {};
__export(client_exports, {
  RoochClient: () => RoochClient,
  isRoochClient: () => isRoochClient
});
module.exports = __toCommonJS(client_exports);
var import_bcs = require("../bcs/index.js");
var import_session = require("../session/index.js");
var import_address = require("../address/index.js");
var import_utils = require("../utils/index.js");
var import_httpTransport = require("./httpTransport.js");
var import_transactions = require("../transactions/index.js");
const ROOCH_CLIENT_BRAND = Symbol.for("@roochnetwork/RoochClient");
function isRoochClient(client) {
  return typeof client === "object" && client !== null && client[ROOCH_CLIENT_BRAND] === true;
}
class RoochClient {
  get [ROOCH_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a rooch RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    this.transport = options.transport ?? new import_httpTransport.RoochHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  async getChainId() {
    if (this.chainID) {
      return this.chainID;
    }
    return this.transport.request({
      method: "rooch_getChainID",
      params: []
    });
  }
  async executeViewFunction(input) {
    const callFunction = new import_transactions.CallFunction(input);
    return await this.transport.request({
      method: "rooch_executeViewFunction",
      params: [
        {
          function_id: callFunction.functionId(),
          args: callFunction.encodeArgs(),
          ty_args: callFunction.typeArgs
        }
      ]
    });
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    option = { withOutput: true }
  }) {
    let transactionHex;
    if (transaction instanceof Uint8Array) {
      transactionHex = (0, import_utils.str)("hex", transaction);
    } else {
      let sender = signer.getRoochAddress().toHexAddress();
      transaction.setChainId(await this.getChainId());
      transaction.setSeqNumber(await this.getSequenceNumber(sender));
      transaction.setSender(sender);
      const auth = await signer.signTransaction(transaction);
      transaction.setAuth(auth);
      transactionHex = `0x${transaction.encode().toHex()}`;
    }
    return await this.transport.request({
      method: "rooch_executeRawTransaction",
      params: [transactionHex, option]
    });
  }
  // Get the states by access_path
  async getStates(params) {
    const result = await this.transport.request({
      method: "rooch_getStates",
      params: [params.accessPath, params.stateOption]
    });
    const typedResult = result;
    return typedResult[0] === null ? [] : typedResult;
  }
  async listStates(params) {
    return await this.transport.request({
      method: "rooch_listStates",
      params: [params.accessPath, params.cursor, params.limit, params.stateOption]
    });
  }
  async getModuleAbi(params) {
    return await this.transport.request({
      method: "rooch_getModuleABI",
      params: [params.moduleAddr, params.moduleName]
    });
  }
  async getEvents(input) {
    return await this.transport.request({
      method: "rooch_getEventsByEventHandle",
      params: [
        input.eventHandleType,
        input.cursor,
        input.limit,
        input.descendingOrder,
        input.eventOptions
      ]
    });
  }
  async queryEvents(input) {
    return await this.transport.request({
      method: "rooch_queryEvents",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  // Query the Inscription via global index by Inscription filter
  async queryInscriptions(input) {
    return await this.transport.request({
      method: "btc_queryInscriptions",
      params: [input.filter, input.cursor, input.limit, input.descendingOrder]
    });
  }
  async queryUTXO(input) {
    return this.transport.request({
      method: "btc_queryUTXOs",
      params: [input.filter, input.cursor, input.limit, input.descendingOrder]
    });
  }
  async queryObjectStates(input) {
    return this.transport.request({
      method: "rooch_queryObjectStates",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  async queryTransactions(input) {
    return this.transport.request({
      method: "rooch_queryTransactions",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  // helper fn
  async getSequenceNumber(address2) {
    const resp = await this.executeViewFunction({
      target: "0x2::account::sequence_number",
      args: [import_bcs.Args.address(address2)]
    });
    if (resp && resp.return_values) {
      return BigInt(resp.return_values[0].decoded_value);
    }
    return BigInt(0);
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !(0, import_address.isValidRoochAddress)(input.owner)) {
      throw new Error("Invalid rooch address");
    }
    return await this.transport.request({
      method: "rooch_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  async getBalances(input) {
    if (!input.owner || !(0, import_address.isValidRoochAddress)(input.owner)) {
      throw new Error("Invalid rooch address");
    }
    return await this.transport.request({
      method: "rooch_getBalances",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  async transfer(input) {
    const tx = new import_transactions.Transaction();
    tx.callFunction({
      target: "0x3::transfer::transfer_coin",
      args: [import_bcs.Args.address(input.recipient), import_bcs.Args.u256(BigInt(input.amount))],
      typeArgs: [(0, import_transactions.normalizeTypeArgsToStr)(input.coinType)]
    });
    return await this.signAndExecuteTransaction({
      transaction: tx,
      signer: input.signer
    });
  }
  async transferObject(input) {
    const tx = new import_transactions.Transaction();
    tx.callFunction({
      target: "0x3::transfer::transfer_object",
      args: [import_bcs.Args.address(input.recipient), import_bcs.Args.objectId(input.objectId)],
      typeArgs: [(0, import_transactions.normalizeTypeArgsToStr)(input.objectType)]
    });
    return await this.signAndExecuteTransaction({
      transaction: tx,
      signer: input.signer
    });
  }
  async resolveBTCAddress(roochAddress) {
    return await this.executeViewFunction({
      target: "0x3::address_mapping::resolve_bitcoin",
      args: [import_bcs.Args.address(roochAddress)]
    });
  }
  async createSession({ sessionArgs, signer }) {
    return import_session.Session.CREATE({
      ...sessionArgs,
      client: this,
      signer
    });
  }
  async removeSession({ authKey, signer }) {
    const tx = new import_transactions.Transaction();
    tx.callFunction({
      target: "0x3::session_key::remove_session_key_entry",
      args: [import_bcs.Args.vec("u8", Array.from((0, import_utils.fromHEX)(authKey)))]
    });
    return (await this.signAndExecuteTransaction({
      transaction: tx,
      signer
    })).execution_info.status.type === "executed";
  }
  async sessionIsExpired({
    address: address2,
    authKey
  }) {
    const result = await this.executeViewFunction({
      target: "0x3::session_key::is_expired_session_key",
      args: [import_bcs.Args.address(address2), import_bcs.Args.vec("u8", Array.from((0, import_utils.fromHEX)(authKey)))]
    });
    if (result.vm_status !== "Executed") {
      throw new Error("view 0x3::session_key::is_expired_session_key fail");
    }
    return result.return_values[0].decoded_value;
  }
  async getSessionKeys({
    address: address2,
    limit,
    cursor
  }) {
    const accessPath = `/resource/${(0, import_address.decodeToRoochAddressStr)(address2)}/0x3::session_key::SessionKeys`;
    const states = await this.getStates({
      accessPath,
      stateOption: {
        decode: true,
        showDisplay: true
      }
    });
    if (states.length === 0) {
      return {
        data: [],
        hasNextPage: false
      };
    }
    const tableId = states[0].decoded_value.value["value"].value["keys"].value["handle"].value["id"];
    const tablePath = `/table/${tableId}`;
    const statePage = await this.listStates({
      accessPath: tablePath,
      cursor,
      limit: limit?.toString(),
      stateOption: {
        decode: true,
        showDisplay: true
      }
    });
    const parseScopes = (data) => {
      const result = new Array();
      for (const scope of data) {
        const value = scope.value;
        result.push(`${value.module_address}::${value.module_name}::${value.function_name}`);
      }
      return result;
    };
    const parseStateToSessionInfo = () => {
      const result = new Array();
      for (const state of statePage.data) {
        const moveValue = state?.state.decoded_value;
        if (moveValue) {
          const val = moveValue.value.value.value;
          result.push({
            appName: val.app_name,
            appUrl: val.app_url,
            authenticationKey: val.authentication_key,
            scopes: parseScopes(val.scopes),
            createTime: parseInt(val.create_time),
            lastActiveTime: parseInt(val.last_active_time),
            maxInactiveInterval: parseInt(val.max_inactive_interval)
          });
        }
      }
      return result.sort((a, b) => b.createTime - a.createTime);
    };
    return {
      data: parseStateToSessionInfo(),
      cursor: statePage.next_cursor,
      hasNextPage: statePage.has_next_page
    };
  }
}
//# sourceMappingURL=client.js.map
