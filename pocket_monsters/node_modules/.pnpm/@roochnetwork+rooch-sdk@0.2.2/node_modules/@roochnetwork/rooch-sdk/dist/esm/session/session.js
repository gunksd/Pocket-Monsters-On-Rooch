import { Args } from "../bcs/index.js";
import { Ed25519Keypair } from "../keypairs/index.js";
import { Transaction } from "../transactions/index.js";
import { BitcoinAddress, RoochAddress } from "../address/index.js";
import { Authenticator, Signer } from "../crypto/index.js";
import { fromHEX } from "../utils/index.js";
const DEFAULT_MAX_INACTIVE_INTERVAL = 1200;
const REQUIRED_SCOPE = "0x3::session_key::remove_session_key_entry";
class Session extends Signer {
  constructor(appName, appUrl, scopes, roochAddress, bitcoinAddress, keypair, maxInactiveInterval, localCreateSessionTime, lastActiveTime) {
    super();
    this.appName = appName;
    this.appUrl = appUrl;
    this.scopes = scopes;
    this.roochAddress = roochAddress;
    this.bitcoinAddress = bitcoinAddress;
    this.keypair = keypair ?? Ed25519Keypair.generate();
    this.maxInactiveInterval = maxInactiveInterval ?? DEFAULT_MAX_INACTIVE_INTERVAL;
    this.localCreateSessionTime = localCreateSessionTime ?? Date.now();
    this.lastActiveTime = lastActiveTime || this.localCreateSessionTime;
  }
  static async CREATE(input) {
    const parsedScopes = input.scopes.map((scope) => {
      if (typeof scope !== "string") {
        return `${scope.address}::${scope.module}::${scope.function}`;
      }
      if (scope.split("::").length !== 3)
        throw Error("invalid scope");
      return scope;
    });
    const allOx3 = "0x3::*::*";
    if (!parsedScopes.find((item) => item === allOx3 || item === REQUIRED_SCOPE)) {
      parsedScopes.push(REQUIRED_SCOPE);
    }
    return new Session(
      input.appName,
      input.appUrl,
      parsedScopes,
      input.signer.getRoochAddress(),
      input.signer.getBitcoinAddress(),
      input.keypair,
      input.maxInactiveInterval
    ).build(input.client, input.signer);
  }
  static fromJson(jsonObj) {
    const {
      appName,
      appUrl,
      scopes,
      secretKey,
      maxInactiveInterval,
      bitcoinAddress,
      roochAddress,
      localCreateSessionTime,
      lastActiveTime
    } = jsonObj;
    return new Session(
      appName,
      appUrl,
      scopes,
      new RoochAddress(roochAddress),
      new BitcoinAddress(bitcoinAddress),
      Ed25519Keypair.fromSecretKey(secretKey),
      maxInactiveInterval,
      localCreateSessionTime,
      lastActiveTime
    );
  }
  sign(input) {
    this.lastActiveTime = Date.now();
    return this.keypair.sign(input);
  }
  signTransaction(input) {
    return Authenticator.rooch(input.hashData(), this);
  }
  getRoochAddress() {
    return this.roochAddress;
  }
  getBitcoinAddress() {
    return this.bitcoinAddress;
  }
  getKeyScheme() {
    return this.keypair.getKeyScheme();
  }
  getPublicKey() {
    return this.keypair.getPublicKey();
  }
  getCreateTime() {
    return this.localCreateSessionTime;
  }
  getAuthKey() {
    return this.keypair.getRoochAddress().toHexAddress();
  }
  async build(client, signer) {
    const [addrs, mods, fns] = this.scopes.map((scope) => {
      return scope.split("::");
    }).reduce(
      (acc, val) => {
        acc[0].push(val[0]);
        acc[1].push(val[1]);
        acc[2].push(val[2]);
        return acc;
      },
      [[], [], []]
    );
    const tx = new Transaction();
    tx.callFunction({
      target: "0x3::session_key::create_session_key_with_multi_scope_entry",
      args: [
        Args.string(this.appName),
        Args.string(this.appUrl),
        Args.vec("u8", Array.from(fromHEX(this.getAuthKey()))),
        Args.vec("address", addrs),
        Args.vec("string", mods),
        Args.vec("string", fns),
        Args.u64(BigInt(this.maxInactiveInterval))
      ],
      info: `Welcome to ${this.appName}
You will authorize session:
${"Scope:\n" + this.scopes.join("\n") + "\nTimeOut:" + this.maxInactiveInterval.toString()}`
    });
    const result = await client.signAndExecuteTransaction({
      transaction: tx,
      signer
    });
    if (result.execution_info.status.type === "executed") {
      return this;
    } else {
      throw Error(`create session failed ${result.execution_info.status}`);
    }
  }
  toJSON() {
    return {
      appName: this.appName,
      appUrl: this.appUrl,
      scopes: this.scopes,
      secretKey: this.keypair.getSecretKey(),
      maxInactiveInterval: this.maxInactiveInterval,
      bitcoinAddress: this.bitcoinAddress.toStr(),
      roochAddress: this.roochAddress.toStr(),
      localCreateSessionTime: this.localCreateSessionTime,
      lastActiveTime: this.lastActiveTime
    };
  }
}
export {
  Session
};
//# sourceMappingURL=session.js.map
