import { bech32 } from "bech32";
import { Signer } from "./signer.js";
import { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from "./signatureScheme.js";
const PRIVATE_KEY_SIZE = 32;
const LEGACY_PRIVATE_KEY_SIZE = 64;
const ROOCH_SECRET_KEY_PREFIX = "roochsecretkey";
class Keypair extends Signer {
}
function decodeRoochSercetKey(value) {
  const { prefix, words } = bech32.decode(value);
  if (prefix !== ROOCH_SECRET_KEY_PREFIX) {
    throw new Error("invalid private key prefix");
  }
  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));
  const secretKey = extendedSecretKey.slice(1);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];
  return {
    schema: signatureScheme,
    secretKey
  };
}
function encodeRoochSercetKey(bytes, scheme) {
  if (bytes.length !== PRIVATE_KEY_SIZE) {
    throw new Error("Invalid bytes length");
  }
  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];
  const privKeyBytes = new Uint8Array(bytes.length + 1);
  privKeyBytes.set([flag]);
  privKeyBytes.set(bytes, 1);
  return bech32.encode(ROOCH_SECRET_KEY_PREFIX, bech32.toWords(privKeyBytes));
}
export {
  Keypair,
  LEGACY_PRIVATE_KEY_SIZE,
  PRIVATE_KEY_SIZE,
  ROOCH_SECRET_KEY_PREFIX,
  decodeRoochSercetKey,
  encodeRoochSercetKey
};
//# sourceMappingURL=keypair.js.map
