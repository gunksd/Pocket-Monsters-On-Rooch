"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bitcoin_exports = {};
__export(bitcoin_exports, {
  BitcoinAddress: () => BitcoinAddress
});
module.exports = __toCommonJS(bitcoin_exports);
var import_base = require("@scure/base");
var import_bcs = require("../bcs/index.js");
var import_utils = require("../utils/index.js");
var import_address = require("./address.js");
var import_rooch = require("./rooch.js");
var import_types2 = require("./types.js");
var import_thirdparty_address = require("./thirdparty-address.js");
const base58check = (0, import_base.createBase58check)(import_utils.sha256);
var BitcoinNetowk = /* @__PURE__ */ ((BitcoinNetowk2) => {
  BitcoinNetowk2[BitcoinNetowk2["Bitcoin"] = 0] = "Bitcoin";
  BitcoinNetowk2[BitcoinNetowk2["Testnet"] = 1] = "Testnet";
  BitcoinNetowk2[BitcoinNetowk2["Signet"] = 2] = "Signet";
  BitcoinNetowk2[BitcoinNetowk2["Regtest"] = 3] = "Regtest";
  return BitcoinNetowk2;
})(BitcoinNetowk || {});
var BitcoinAddressType = /* @__PURE__ */ ((BitcoinAddressType2) => {
  BitcoinAddressType2[BitcoinAddressType2["pkh"] = 0] = "pkh";
  BitcoinAddressType2[BitcoinAddressType2["sh"] = 1] = "sh";
  BitcoinAddressType2[BitcoinAddressType2["wpkh"] = 2] = "wpkh";
  BitcoinAddressType2[BitcoinAddressType2["wsh"] = 2] = "wsh";
  BitcoinAddressType2[BitcoinAddressType2["tr"] = 2] = "tr";
  return BitcoinAddressType2;
})(BitcoinAddressType || {});
class BitcoinAddress extends import_thirdparty_address.ThirdPartyAddress {
  constructor(input) {
    super(input);
    let info = this.decode();
    this.bytes = this.wrapAddress(info.type, info.bytes, info.version);
  }
  // static fromBytes(input: Bytes) {
  //   switch (input[0]) {
  //     case BitcoinAddressType.pkh:
  //       return ''
  //     // case: sh = 1,
  //     case BitcoinAddressType.wpkh:
  //       bech32m.encode()
  //   }
  // }
  toBytes() {
    return (0, import_utils.bytes)("utf8", this.rawAddress);
  }
  genMultiChainAddress() {
    return import_bcs.bcs.MultiChainAddress.serialize({
      multiChainId: import_types2.MultiChainID.Bitcoin,
      rawAddress: this.bytes
    }).toBytes();
  }
  genRoochAddress() {
    if (!this.roochAddress) {
      this.roochAddress = new import_rooch.RoochAddress((0, import_utils.blake2b)(this.bytes, { dkLen: import_address.ROOCH_ADDRESS_LENGTH }));
    }
    return this.roochAddress;
  }
  decode() {
    let input = this.rawAddress;
    if (input.length < 14 || input.length > 74)
      throw new Error("Invalid address length");
    const bech32_network = (() => {
      const sep = input.lastIndexOf("1");
      const bech32Prefix = sep === -1 ? input : input.substring(0, sep);
      switch (bech32Prefix) {
        case "bc":
          return 0 /* Bitcoin */;
        case "tb":
          return 1 /* Testnet */;
        case "bcrt":
          return 3 /* Regtest */;
        default:
          return void 0;
      }
    })();
    if (bech32_network !== void 0) {
      let res;
      try {
        res = import_base.bech32.decode(input);
        if (res.words[0] !== 0)
          throw new Error(`bech32: wrong version=${res.words[0]}`);
      } catch (_) {
        res = import_base.bech32m.decode(input);
        if (res.words[0] === 0)
          throw new Error(`bech32m: wrong version=${res.words[0]}`);
      }
      const [version, ...program] = res.words;
      const data2 = import_base.bech32.fromWords(program);
      (0, import_utils.validateWitness)(version, data2);
      if (version === 0 && data2.length === 32)
        return {
          bytes: data2,
          type: 2 /* wsh */,
          version
        };
      else if (version === 0 && data2.length === 20)
        return {
          bytes: data2,
          type: 2 /* wpkh */,
          version
        };
      else if (version === 1 && data2.length === 32)
        return {
          bytes: data2,
          type: 2 /* tr */,
          version
        };
      else
        throw new Error("Unknown witness program");
    }
    const data = base58check.decode(input);
    if (data.length !== 21)
      throw new Error("Invalid base58 address");
    if (data[0] === 0) {
      return {
        bytes: data.slice(1),
        type: 0 /* pkh */
      };
    } else if (data[0] === 5) {
      return { bytes: data.slice(1), type: 1 /* sh */ };
    }
    throw new Error(`Invalid address prefix=${data[0]}`);
  }
  wrapAddress(type, bytes2, version) {
    const addr = new Uint8Array(bytes2.length + 1 + (version !== void 0 ? 1 : 0));
    addr.set([type]);
    if (version !== void 0) {
      addr.set([version], 1);
      addr.set(bytes2, 2);
    } else {
      addr.set(bytes2, 1);
    }
    return addr;
  }
}
//# sourceMappingURL=bitcoin.js.map
