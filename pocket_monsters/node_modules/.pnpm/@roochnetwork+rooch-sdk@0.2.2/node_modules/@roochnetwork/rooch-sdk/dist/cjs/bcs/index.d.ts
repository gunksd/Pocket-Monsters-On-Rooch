export { BcsType, type BcsTypeOptions } from '@mysten/bcs';
export { Args, type ArgType } from './args.js';
export { Serializer } from './serializer.js';
export { type StructTag, type TypeTag } from './types.js';
export declare const RoochBcs: {
    u8(options?: import("@mysten/bcs").BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u16(options?: import("@mysten/bcs").BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u32(options?: import("@mysten/bcs").BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u64(options?: import("@mysten/bcs").BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    u128(options?: import("@mysten/bcs").BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    u256(options?: import("@mysten/bcs").BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    bool(options?: import("@mysten/bcs").BcsTypeOptions<boolean, boolean> | undefined): import("@mysten/bcs").BcsType<boolean, boolean>;
    uleb128(options?: import("@mysten/bcs").BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    bytes<T extends number>(size: T, options?: import("@mysten/bcs").BcsTypeOptions<Uint8Array, Iterable<number>> | undefined): import("@mysten/bcs").BcsType<Uint8Array, Uint8Array>;
    string(options?: import("@mysten/bcs").BcsTypeOptions<string, string> | undefined): import("@mysten/bcs").BcsType<string, string>;
    fixedArray<T_1, Input>(size: number, type: import("@mysten/bcs").BcsType<T_1, Input>, options?: import("@mysten/bcs").BcsTypeOptions<T_1[], Iterable<Input> & {
        length: number;
    }> | undefined): import("@mysten/bcs").BcsType<T_1[], Iterable<Input> & {
        length: number;
    }>;
    option<T_2, Input_1>(type: import("@mysten/bcs").BcsType<T_2, Input_1>): import("@mysten/bcs").BcsType<T_2 | null, Input_1 | null | undefined>;
    vector<T_3, Input_2>(type: import("@mysten/bcs").BcsType<T_3, Input_2>, options?: import("@mysten/bcs").BcsTypeOptions<T_3[], Iterable<Input_2> & {
        length: number;
    }> | undefined): import("@mysten/bcs").BcsType<T_3[], Iterable<Input_2> & {
        length: number;
    }>;
    tuple<const Types extends readonly import("@mysten/bcs").BcsType<any, any>[]>(types: Types, options?: import("@mysten/bcs").BcsTypeOptions<{ -readonly [K in keyof Types]: Types[K] extends import("@mysten/bcs").BcsType<infer T_4, any> ? T_4 : never; }, { [K_1 in keyof Types]: Types[K_1] extends import("@mysten/bcs").BcsType<any, infer T_5> ? T_5 : never; }> | undefined): import("@mysten/bcs").BcsType<{ -readonly [K_2 in keyof Types]: Types[K_2] extends import("@mysten/bcs").BcsType<infer T_6, any> ? T_6 : never; }, { [K_3 in keyof Types]: Types[K_3] extends import("@mysten/bcs").BcsType<any, infer T_7> ? T_7 : never; }>;
    struct<T_8 extends Record<string, import("@mysten/bcs").BcsType<any, any>>>(name: string, fields: T_8, options?: Omit<import("@mysten/bcs").BcsTypeOptions<{ [K_4 in keyof T_8]: T_8[K_4] extends import("@mysten/bcs").BcsType<infer U, any> ? U : never; }, { [K_5 in keyof T_8]: T_8[K_5] extends import("@mysten/bcs").BcsType<any, infer U_1> ? U_1 : never; }>, "name"> | undefined): import("@mysten/bcs").BcsType<{ [K_6 in keyof T_8]: T_8[K_6] extends import("@mysten/bcs").BcsType<infer U_2, any> ? U_2 : never; }, { [K_7 in keyof T_8]: T_8[K_7] extends import("@mysten/bcs").BcsType<any, infer U_3> ? U_3 : never; }>;
    enum<T_9 extends Record<string, import("@mysten/bcs").BcsType<any, any> | null>>(name: string, values: T_9, options?: Omit<import("@mysten/bcs").BcsTypeOptions<import("@mysten/bcs").EnumOutputShape<{ [K_8 in keyof T_9]: T_9[K_8] extends import("@mysten/bcs").BcsType<infer U_4, any> ? U_4 : true; }>, import("@mysten/bcs").EnumInputShape<{ [K_9 in keyof T_9]: T_9[K_9] extends import("@mysten/bcs").BcsType<any, infer U_5> ? U_5 : boolean | object | null; }>>, "name"> | undefined): import("@mysten/bcs").BcsType<import("@mysten/bcs").EnumOutputShape<{ [K_10 in keyof T_9]: T_9[K_10] extends import("@mysten/bcs").BcsType<infer U_6, any> ? U_6 : true; }>, import("@mysten/bcs").EnumInputShape<{ [K_11 in keyof T_9]: T_9[K_11] extends import("@mysten/bcs").BcsType<any, infer U_7> ? U_7 : boolean | object | null; }>>;
    map<K_12, V, InputK = K_12, InputV = V>(keyType: import("@mysten/bcs").BcsType<K_12, InputK>, valueType: import("@mysten/bcs").BcsType<V, InputV>): import("@mysten/bcs").BcsType<Map<K_12, V>, Map<InputK, InputV>>;
    lazy<T_10 extends import("@mysten/bcs").BcsType<any, any>>(cb: () => T_10): T_10;
    U8: import("@mysten/bcs").BcsType<number, number>;
    U16: import("@mysten/bcs").BcsType<number, number>;
    U32: import("@mysten/bcs").BcsType<number, number>;
    U64: import("@mysten/bcs").BcsType<string, string | number | bigint>;
    U128: import("@mysten/bcs").BcsType<string, string | number | bigint>;
    U256: import("@mysten/bcs").BcsType<string, string | number | bigint>;
    Bool: import("@mysten/bcs").BcsType<boolean, boolean>;
    Raw: <T_11, Input_3>(type: import("@mysten/bcs").BcsType<T_11, Input_3>, options?: import("@mysten/bcs").BcsTypeOptions<T_11[], Iterable<Input_3> & {
        length: number;
    }> | undefined) => import("@mysten/bcs").BcsType<T_11[], Iterable<Input_3> & {
        length: number;
    }>;
    String: import("@mysten/bcs").BcsType<string, string>;
    Address: import("@mysten/bcs").BcsType<string, import("../index.js").address>;
    MultiChainAddress: import("@mysten/bcs").BcsType<{
        multiChainId: bigint;
        rawAddress: number[];
    }, {
        multiChainId: number | bigint;
        rawAddress: Iterable<number> & {
            length: number;
        };
    }>;
    ObjectId: import("@mysten/bcs").BcsType<string, string | Uint8Array[]>;
    BitcoinAuthPayload: import("@mysten/bcs").BcsType<{
        signature: Uint8Array;
        messagePrefix: Uint8Array;
        messageInfo: Uint8Array;
        publicKey: Uint8Array;
        fromAddress: Uint8Array;
    }, {
        signature: string | Uint8Array;
        messagePrefix: string | Uint8Array;
        messageInfo: string | Uint8Array;
        publicKey: string | Uint8Array;
        fromAddress: string | Uint8Array;
    }>;
    ModuleId: import("@mysten/bcs").BcsType<{
        address: string;
        name: string;
    }, {
        address: import("../index.js").address;
        name: string;
    }>;
    FunctionId: import("@mysten/bcs").BcsType<{
        moduleId: {
            address: string;
            name: string;
        };
        name: string;
    }, {
        moduleId: {
            address: import("../index.js").address;
            name: string;
        };
        name: string;
    }>;
    ScriptCall: import("@mysten/bcs").BcsType<{
        code: number[];
        args: number[];
        typeArgs: string[];
    }, {
        code: string | Uint8Array;
        args: Iterable<number> & {
            length: number;
        };
        typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
            length: number;
        };
    }>;
    CallFunction: import("@mysten/bcs").BcsType<{
        functionId: {
            moduleId: {
                address: string;
                name: string;
            };
            name: string;
        };
        typeArgs: string[];
        args: number[][];
    }, {
        functionId: {
            moduleId: {
                address: import("../index.js").address;
                name: string;
            };
            name: string;
        };
        typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
            length: number;
        };
        args: Iterable<Iterable<number> & {
            length: number;
        }> & {
            length: number;
        };
    }>;
    MoveAction: import("@mysten/bcs").BcsType<{
        readonly [x: number]: string;
        toString: () => string;
        charAt: (pos: number) => string;
        charCodeAt: (index: number) => number;
        concat: (...strings: string[]) => string;
        indexOf: (searchString: string, position?: number | undefined) => number;
        lastIndexOf: (searchString: string, position?: number | undefined) => number;
        localeCompare: {
            (that: string): number;
            (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
            (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
        };
        match: {
            (regexp: string | RegExp): RegExpMatchArray | null;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray | null;
            }): RegExpMatchArray | null;
        };
        replace: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice: (start?: number | undefined, end?: number | undefined) => string;
        split: {
            (separator: string | RegExp, limit?: number | undefined): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number | undefined): string[];
            }, limit?: number | undefined): string[];
        };
        substring: (start: number, end?: number | undefined) => string;
        toLowerCase: () => string;
        toLocaleLowerCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        toUpperCase: () => string;
        toLocaleUpperCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        trim: () => string;
        readonly length: number;
        substr: (from: number, length?: number | undefined) => string;
        valueOf: () => string;
        codePointAt: (pos: number) => number | undefined;
        includes: (searchString: string, position?: number | undefined) => boolean;
        endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
        normalize: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string | undefined): string;
        };
        repeat: (count: number) => string;
        startsWith: (searchString: string, position?: number | undefined) => boolean;
        anchor: (name: string) => string;
        big: () => string;
        blink: () => string;
        bold: () => string;
        fixed: () => string;
        fontcolor: (color: string) => string;
        fontsize: {
            (size: number): string;
            (size: string): string;
        };
        italics: () => string;
        link: (url: string) => string;
        small: () => string;
        strike: () => string;
        sub: () => string;
        sup: () => string;
        padStart: (maxLength: number, fillString?: string | undefined) => string;
        padEnd: (maxLength: number, fillString?: string | undefined) => string;
        trimEnd: () => string;
        trimStart: () => string;
        trimLeft: () => string;
        trimRight: () => string;
        matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
        replaceAll: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        };
        at: (index: number) => string | undefined;
        [Symbol.iterator]: () => IterableIterator<string>;
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        code: number[];
        args: number[];
        typeArgs: string[];
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        functionId: {
            moduleId: {
                address: string;
                name: string;
            };
            name: string;
        };
        typeArgs: string[];
        args: number[][];
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        readonly [x: number]: string;
        toString: () => string;
        charAt: (pos: number) => string;
        charCodeAt: (index: number) => number;
        concat: (...strings: string[]) => string;
        indexOf: (searchString: string, position?: number | undefined) => number;
        lastIndexOf: (searchString: string, position?: number | undefined) => number;
        localeCompare: {
            (that: string): number;
            (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
            (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
        };
        match: {
            (regexp: string | RegExp): RegExpMatchArray | null;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray | null;
            }): RegExpMatchArray | null;
        };
        replace: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice: (start?: number | undefined, end?: number | undefined) => string;
        split: {
            (separator: string | RegExp, limit?: number | undefined): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number | undefined): string[];
            }, limit?: number | undefined): string[];
        };
        substring: (start: number, end?: number | undefined) => string;
        toLowerCase: () => string;
        toLocaleLowerCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        toUpperCase: () => string;
        toLocaleUpperCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        trim: () => string;
        readonly length: number;
        substr: (from: number, length?: number | undefined) => string;
        valueOf: () => string;
        codePointAt: (pos: number) => number | undefined;
        includes: (searchString: string, position?: number | undefined) => boolean;
        endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
        normalize: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string | undefined): string;
        };
        repeat: (count: number) => string;
        startsWith: (searchString: string, position?: number | undefined) => boolean;
        anchor: (name: string) => string;
        big: () => string;
        blink: () => string;
        bold: () => string;
        fixed: () => string;
        fontcolor: (color: string) => string;
        fontsize: {
            (size: number): string;
            (size: string): string;
        };
        italics: () => string;
        link: (url: string) => string;
        small: () => string;
        strike: () => string;
        sub: () => string;
        sup: () => string;
        padStart: (maxLength: number, fillString?: string | undefined) => string;
        padEnd: (maxLength: number, fillString?: string | undefined) => string;
        trimEnd: () => string;
        trimStart: () => string;
        trimLeft: () => string;
        trimRight: () => string;
        matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
        replaceAll: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        };
        at: (index: number) => string | undefined;
        [Symbol.iterator]: () => IterableIterator<string>;
        kind: "$kind" | "ScriptCall" | "CallFunction";
    }, {
        code: string | Uint8Array;
        args: Iterable<number> & {
            length: number;
        };
        typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
            length: number;
        };
        kind: "ScriptCall";
    } | {
        functionId: {
            moduleId: {
                address: import("../index.js").address;
                name: string;
            };
            name: string;
        };
        typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
            length: number;
        };
        args: Iterable<Iterable<number> & {
            length: number;
        }> & {
            length: number;
        };
        kind: "CallFunction";
    }>;
    RoochTransactionData: import("@mysten/bcs").BcsType<{
        sender: string;
        sequenceNumber: string;
        chainId: string;
        maxGas: string;
        action: {
            readonly [x: number]: string;
            toString: () => string;
            charAt: (pos: number) => string;
            charCodeAt: (index: number) => number;
            concat: (...strings: string[]) => string;
            indexOf: (searchString: string, position?: number | undefined) => number;
            lastIndexOf: (searchString: string, position?: number | undefined) => number;
            localeCompare: {
                (that: string): number;
                (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
                (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
            };
            match: {
                (regexp: string | RegExp): RegExpMatchArray | null;
                (matcher: {
                    [Symbol.match](string: string): RegExpMatchArray | null;
                }): RegExpMatchArray | null;
            };
            replace: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replaceValue: string): string;
                }, replaceValue: string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
                }, replacer: (substring: string, ...args: any[]) => string): string;
            };
            search: {
                (regexp: string | RegExp): number;
                (searcher: {
                    [Symbol.search](string: string): number;
                }): number;
            };
            slice: (start?: number | undefined, end?: number | undefined) => string;
            split: {
                (separator: string | RegExp, limit?: number | undefined): string[];
                (splitter: {
                    [Symbol.split](string: string, limit?: number | undefined): string[];
                }, limit?: number | undefined): string[];
            };
            substring: (start: number, end?: number | undefined) => string;
            toLowerCase: () => string;
            toLocaleLowerCase: {
                (locales?: string | string[] | undefined): string;
                (locales?: Intl.LocalesArgument): string;
            };
            toUpperCase: () => string;
            toLocaleUpperCase: {
                (locales?: string | string[] | undefined): string;
                (locales?: Intl.LocalesArgument): string;
            };
            trim: () => string;
            readonly length: number;
            substr: (from: number, length?: number | undefined) => string;
            valueOf: () => string;
            codePointAt: (pos: number) => number | undefined;
            includes: (searchString: string, position?: number | undefined) => boolean;
            endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
            normalize: {
                (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
                (form?: string | undefined): string;
            };
            repeat: (count: number) => string;
            startsWith: (searchString: string, position?: number | undefined) => boolean;
            anchor: (name: string) => string;
            big: () => string;
            blink: () => string;
            bold: () => string;
            fixed: () => string;
            fontcolor: (color: string) => string;
            fontsize: {
                (size: number): string;
                (size: string): string;
            };
            italics: () => string;
            link: (url: string) => string;
            small: () => string;
            strike: () => string;
            sub: () => string;
            sup: () => string;
            padStart: (maxLength: number, fillString?: string | undefined) => string;
            padEnd: (maxLength: number, fillString?: string | undefined) => string;
            trimEnd: () => string;
            trimStart: () => string;
            trimLeft: () => string;
            trimRight: () => string;
            matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
            replaceAll: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            };
            at: (index: number) => string | undefined;
            [Symbol.iterator]: () => IterableIterator<string>;
            kind: "$kind" | "ScriptCall" | "CallFunction";
        } | {
            code: number[];
            args: number[];
            typeArgs: string[];
            kind: "$kind" | "ScriptCall" | "CallFunction";
        } | {
            functionId: {
                moduleId: {
                    address: string;
                    name: string;
                };
                name: string;
            };
            typeArgs: string[];
            args: number[][];
            kind: "$kind" | "ScriptCall" | "CallFunction";
        } | {
            readonly [x: number]: string;
            toString: () => string;
            charAt: (pos: number) => string;
            charCodeAt: (index: number) => number;
            concat: (...strings: string[]) => string;
            indexOf: (searchString: string, position?: number | undefined) => number;
            lastIndexOf: (searchString: string, position?: number | undefined) => number;
            localeCompare: {
                (that: string): number;
                (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
                (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
            };
            match: {
                (regexp: string | RegExp): RegExpMatchArray | null;
                (matcher: {
                    [Symbol.match](string: string): RegExpMatchArray | null;
                }): RegExpMatchArray | null;
            };
            replace: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replaceValue: string): string;
                }, replaceValue: string): string;
                (searchValue: {
                    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
                }, replacer: (substring: string, ...args: any[]) => string): string;
            };
            search: {
                (regexp: string | RegExp): number;
                (searcher: {
                    [Symbol.search](string: string): number;
                }): number;
            };
            slice: (start?: number | undefined, end?: number | undefined) => string;
            split: {
                (separator: string | RegExp, limit?: number | undefined): string[];
                (splitter: {
                    [Symbol.split](string: string, limit?: number | undefined): string[];
                }, limit?: number | undefined): string[];
            };
            substring: (start: number, end?: number | undefined) => string;
            toLowerCase: () => string;
            toLocaleLowerCase: {
                (locales?: string | string[] | undefined): string;
                (locales?: Intl.LocalesArgument): string;
            };
            toUpperCase: () => string;
            toLocaleUpperCase: {
                (locales?: string | string[] | undefined): string;
                (locales?: Intl.LocalesArgument): string;
            };
            trim: () => string;
            readonly length: number;
            substr: (from: number, length?: number | undefined) => string;
            valueOf: () => string;
            codePointAt: (pos: number) => number | undefined;
            includes: (searchString: string, position?: number | undefined) => boolean;
            endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
            normalize: {
                (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
                (form?: string | undefined): string;
            };
            repeat: (count: number) => string;
            startsWith: (searchString: string, position?: number | undefined) => boolean;
            anchor: (name: string) => string;
            big: () => string;
            blink: () => string;
            bold: () => string;
            fixed: () => string;
            fontcolor: (color: string) => string;
            fontsize: {
                (size: number): string;
                (size: string): string;
            };
            italics: () => string;
            link: (url: string) => string;
            small: () => string;
            strike: () => string;
            sub: () => string;
            sup: () => string;
            padStart: (maxLength: number, fillString?: string | undefined) => string;
            padEnd: (maxLength: number, fillString?: string | undefined) => string;
            trimEnd: () => string;
            trimStart: () => string;
            trimLeft: () => string;
            trimRight: () => string;
            matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
            replaceAll: {
                (searchValue: string | RegExp, replaceValue: string): string;
                (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            };
            at: (index: number) => string | undefined;
            [Symbol.iterator]: () => IterableIterator<string>;
            kind: "$kind" | "ScriptCall" | "CallFunction";
        };
    }, {
        sender: import("../index.js").address;
        sequenceNumber: string | number | bigint;
        chainId: string | number | bigint;
        maxGas: string | number | bigint;
        action: {
            code: string | Uint8Array;
            args: Iterable<number> & {
                length: number;
            };
            typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
                length: number;
            };
            kind: "ScriptCall";
        } | {
            functionId: {
                moduleId: {
                    address: import("../index.js").address;
                    name: string;
                };
                name: string;
            };
            typeArgs: Iterable<string | import("./types.js").BcsTypeTag> & {
                length: number;
            };
            args: Iterable<Iterable<number> & {
                length: number;
            }> & {
                length: number;
            };
            kind: "CallFunction";
        };
    }>;
    Authenticator: import("@mysten/bcs").BcsType<{
        authValidatorId: string;
        payload: number[];
    }, {
        authValidatorId: string | number | bigint;
        payload: Iterable<number> & {
            length: number;
        };
    }>;
    RoochTransaction: import("@mysten/bcs").BcsType<{
        data: number[];
        auth: number[];
    }, {
        data: Iterable<number> & {
            length: number;
        };
        auth: Iterable<number> & {
            length: number;
        };
    }>;
};
export { RoochBcs as bcs };
