{
  "version": 3,
  "sources": ["../../../src/address/util.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bech32m } from '@scure/base'\n\nimport { isBytes, str } from '../utils/bytes.js'\nimport { fromHEX, getHexByteLength, isHex } from '../utils/hex.js'\nimport { address } from '../types/rooch.js'\nimport { Bytes } from '../types/bytes.js'\n\nimport { BitcoinAddress } from './bitcoin.js'\nimport { ROOCH_ADDRESS_LENGTH, ROOCH_BECH32_PREFIX } from './address.js'\n\nexport function decodeToRoochAddressStr(input: address): string {\n  if (typeof input === 'string') {\n    if (isValidRoochAddress(input)) {\n      return input\n    }\n\n    if (isValidBitcoinAddress(input)) {\n      return new BitcoinAddress(input).genRoochAddress().toHexAddress()\n    }\n\n    throw Error('Invalid Address')\n  }\n\n  if (isBytes(input)) {\n    return str('hex', input)\n  }\n\n  return decodeToRoochAddressStr(input.toStr())\n}\n\nexport function convertToRoochAddressBytes(input: address): Bytes {\n  if (typeof input === 'string') {\n    const normalizeAddress = normalizeRoochAddress(input)\n    if (isHex(normalizeAddress) && getHexByteLength(normalizeAddress) === ROOCH_ADDRESS_LENGTH) {\n      return fromHEX(normalizeAddress)\n    }\n\n    if (input.startsWith(ROOCH_BECH32_PREFIX)) {\n      const decode = bech32m.decode(input)\n      const bytes = bech32m.fromWords(decode.words)\n\n      if (decode.prefix === ROOCH_BECH32_PREFIX && bytes.length === ROOCH_ADDRESS_LENGTH) {\n        return bytes\n      }\n    }\n    // throw new Error('invalid address')\n\n    return new BitcoinAddress(input).genRoochAddress().toBytes()\n  }\n\n  return isBytes(input) ? input : convertToRoochAddressBytes(input.toStr())\n}\n\nexport function isValidBitcoinAddress(input: string): boolean {\n  try {\n    new BitcoinAddress(input)\n    return true\n  } catch (_) {}\n\n  return false\n}\n\nexport function isValidRoochAddress(input: address): input is string {\n  if (typeof input === 'string') {\n    const normalizeAddress = normalizeRoochAddress(input)\n    if (isHex(normalizeAddress) && getHexByteLength(normalizeAddress) === ROOCH_ADDRESS_LENGTH) {\n      return true\n    }\n\n    if (input.startsWith(ROOCH_BECH32_PREFIX)) {\n      const decode = bech32m.decode(input)\n      const bytes = bech32m.fromWords(decode.words)\n\n      return decode.prefix === ROOCH_BECH32_PREFIX && bytes.length === ROOCH_ADDRESS_LENGTH\n    }\n\n    return false\n  }\n\n  return isBytes(input) ? input.length === ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr())\n}\n\nexport function isValidAddress(input: address): input is string {\n  if (typeof input === 'string') {\n    if (isValidRoochAddress(input)) {\n      return true\n    }\n\n    return isValidBitcoinAddress(input)\n  }\n\n  return isBytes(input) ? input.length === ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr())\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `ROOCH_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeRoochAddress(input: string, forceAdd0x: boolean = false): string {\n  let address = input.toLowerCase()\n  if (!forceAdd0x && address.startsWith('0x')) {\n    address = address.slice(2)\n  }\n  return `0x${address.padStart(ROOCH_ADDRESS_LENGTH * 2, '0')}`\n}\n\nexport function canonicalRoochAddress(input: string, forceAdd0x: boolean = false): string {\n  return normalizeRoochAddress(input, forceAdd0x).slice(2)\n}\n"],
  "mappings": "AAGA,SAAS,eAAe;AAExB,SAAS,SAAS,WAAW;AAC7B,SAAS,SAAS,kBAAkB,aAAa;AAIjD,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB,2BAA2B;AAEnD,SAAS,wBAAwB,OAAwB;AAC9D,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,oBAAoB,KAAK,GAAG;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,sBAAsB,KAAK,GAAG;AAChC,aAAO,IAAI,eAAe,KAAK,EAAE,gBAAgB,EAAE,aAAa;AAAA,IAClE;AAEA,UAAM,MAAM,iBAAiB;AAAA,EAC/B;AAEA,MAAI,QAAQ,KAAK,GAAG;AAClB,WAAO,IAAI,OAAO,KAAK;AAAA,EACzB;AAEA,SAAO,wBAAwB,MAAM,MAAM,CAAC;AAC9C;AAEO,SAAS,2BAA2B,OAAuB;AAChE,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,mBAAmB,sBAAsB,KAAK;AACpD,QAAI,MAAM,gBAAgB,KAAK,iBAAiB,gBAAgB,MAAM,sBAAsB;AAC1F,aAAO,QAAQ,gBAAgB;AAAA,IACjC;AAEA,QAAI,MAAM,WAAW,mBAAmB,GAAG;AACzC,YAAM,SAAS,QAAQ,OAAO,KAAK;AACnC,YAAM,QAAQ,QAAQ,UAAU,OAAO,KAAK;AAE5C,UAAI,OAAO,WAAW,uBAAuB,MAAM,WAAW,sBAAsB;AAClF,eAAO;AAAA,MACT;AAAA,IACF;AAGA,WAAO,IAAI,eAAe,KAAK,EAAE,gBAAgB,EAAE,QAAQ;AAAA,EAC7D;AAEA,SAAO,QAAQ,KAAK,IAAI,QAAQ,2BAA2B,MAAM,MAAM,CAAC;AAC1E;AAEO,SAAS,sBAAsB,OAAwB;AAC5D,MAAI;AACF,QAAI,eAAe,KAAK;AACxB,WAAO;AAAA,EACT,SAAS,GAAP;AAAA,EAAW;AAEb,SAAO;AACT;AAEO,SAAS,oBAAoB,OAAiC;AACnE,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,mBAAmB,sBAAsB,KAAK;AACpD,QAAI,MAAM,gBAAgB,KAAK,iBAAiB,gBAAgB,MAAM,sBAAsB;AAC1F,aAAO;AAAA,IACT;AAEA,QAAI,MAAM,WAAW,mBAAmB,GAAG;AACzC,YAAM,SAAS,QAAQ,OAAO,KAAK;AACnC,YAAM,QAAQ,QAAQ,UAAU,OAAO,KAAK;AAE5C,aAAO,OAAO,WAAW,uBAAuB,MAAM,WAAW;AAAA,IACnE;AAEA,WAAO;AAAA,EACT;AAEA,SAAO,QAAQ,KAAK,IAAI,MAAM,WAAW,uBAAuB,eAAe,MAAM,MAAM,CAAC;AAC9F;AAEO,SAAS,eAAe,OAAiC;AAC9D,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,oBAAoB,KAAK,GAAG;AAC9B,aAAO;AAAA,IACT;AAEA,WAAO,sBAAsB,KAAK;AAAA,EACpC;AAEA,SAAO,QAAQ,KAAK,IAAI,MAAM,WAAW,uBAAuB,eAAe,MAAM,MAAM,CAAC;AAC9F;AAaO,SAAS,sBAAsB,OAAe,aAAsB,OAAe;AACxF,MAAIA,WAAU,MAAM,YAAY;AAChC,MAAI,CAAC,cAAcA,SAAQ,WAAW,IAAI,GAAG;AAC3C,IAAAA,WAAUA,SAAQ,MAAM,CAAC;AAAA,EAC3B;AACA,SAAO,KAAKA,SAAQ,SAAS,uBAAuB,GAAG,GAAG;AAC5D;AAEO,SAAS,sBAAsB,OAAe,aAAsB,OAAe;AACxF,SAAO,sBAAsB,OAAO,UAAU,EAAE,MAAM,CAAC;AACzD;",
  "names": ["address"]
}
