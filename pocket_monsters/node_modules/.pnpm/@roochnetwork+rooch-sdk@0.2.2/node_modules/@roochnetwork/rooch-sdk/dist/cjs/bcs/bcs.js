"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bcs_exports = {};
__export(bcs_exports, {
  Address: () => Address,
  Authenticator: () => Authenticator,
  BitcoinAuthPayload: () => BitcoinAuthPayload,
  CallFunction: () => CallFunction,
  FunctionId: () => FunctionId,
  ModuleId: () => ModuleId,
  MoveAction: () => MoveAction,
  MultiChainAddress: () => MultiChainAddress,
  ObjectId: () => ObjectId,
  RawBytes: () => RawBytes,
  RoochTransaction: () => RoochTransaction,
  RoochTransactionData: () => RoochTransactionData,
  ScriptCall: () => ScriptCall,
  StructTag: () => StructTag,
  TypeTag: () => TypeTag,
  Vector: () => Vector,
  raw: () => raw
});
module.exports = __toCommonJS(bcs_exports);
var import_bcs = require("@mysten/bcs");
var import_utils = require("../utils/index.js");
var import_address = require("../address/index.js");
var import_serializer = require("./serializer.js");
function enumKind(type) {
  return type.transform({
    input: ({ kind, ...val }) => ({
      [kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
const raw = (type, options) => {
  return new import_bcs.BcsType({
    name: `vector<${type.name}>`,
    read: (reader) => {
      const result = [];
      for (let i = 0; i < length; i++) {
        result[i] = type.read(reader);
      }
      return result;
    },
    write: (value, writer) => {
      for (const item of value) {
        type.write(item, writer);
      }
    },
    ...options,
    validate: (value) => {
      options?.validate?.(value);
      if (!("length" in value)) {
        throw new TypeError(`Expected array, found ${typeof value}`);
      }
    }
  });
};
const RawBytes = (coder = "hex") => {
  return raw(import_bcs.bcs.u8()).transform({
    input: (input) => typeof input === "string" ? (0, import_utils.bytes)(coder, input) : input,
    output: (input) => input
  });
};
const Vector = (coder = "hex") => {
  return import_bcs.bcs.vector(import_bcs.bcs.u8()).transform({
    input: (input) => typeof input === "string" ? (0, import_utils.bytes)(coder, input) : input,
    output: (input) => new Uint8Array(input)
  });
};
const Address = import_bcs.bcs.bytes(import_address.ROOCH_ADDRESS_LENGTH).transform({
  validate: (input) => {
    if (!(0, import_address.isValidAddress)(input)) {
      throw new Error(`Invalid address ${input}`);
    }
  },
  input: (input) => (0, import_address.convertToRoochAddressBytes)(input),
  output: (val) => (0, import_address.normalizeRoochAddress)((0, import_utils.toHEX)(val))
});
const MultiChainAddress = import_bcs.bcs.struct("MultiChainAddress", {
  multiChainId: import_bcs.bcs.u64().transform({
    input: (input) => typeof typeof input === "number" ? BigInt(input) : input,
    output: (input) => BigInt(input)
  }),
  rawAddress: import_bcs.bcs.vector(import_bcs.bcs.u8())
});
const ObjectId = import_bcs.bcs.vector(Address).transform({
  input: (input) => {
    if (typeof input === "string") {
      const normalizeId = (0, import_address.normalizeRoochAddress)(input);
      let bytes2 = (0, import_utils.fromHEX)(normalizeId);
      let addresses = [];
      for (let i = 0; i < bytes2.length; i += import_address.ROOCH_ADDRESS_LENGTH) {
        let chunk = bytes2.slice(i, i + import_address.ROOCH_ADDRESS_LENGTH);
        if (chunk.length !== import_address.ROOCH_ADDRESS_LENGTH) {
          throw new Error("Invalid chunk size");
        }
        addresses.push(chunk);
      }
      return addresses;
    }
    return input;
  },
  output: (val) => {
    return val.join("");
  }
});
const InnerTypeTag = import_bcs.bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: import_bcs.bcs.lazy(() => InnerTypeTag),
  struct: import_bcs.bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
const StructTag = import_bcs.bcs.struct("StructTag", {
  address: Address,
  module: import_bcs.bcs.string(),
  name: import_bcs.bcs.string(),
  typeParams: import_bcs.bcs.vector(InnerTypeTag)
});
const TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? import_serializer.Serializer.typeTagParseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => import_serializer.Serializer.tagToString(typeTag)
});
const BitcoinAuthPayload = import_bcs.bcs.struct("AuthPayload", {
  signature: Vector(),
  messagePrefix: Vector("utf8"),
  messageInfo: Vector("utf8"),
  publicKey: Vector("hex"),
  fromAddress: Vector("utf8")
});
const ModuleId = import_bcs.bcs.struct("ModuleId", {
  address: Address,
  name: import_bcs.bcs.string()
});
const FunctionId = import_bcs.bcs.struct("FunctionId", {
  moduleId: ModuleId,
  name: import_bcs.bcs.string()
});
const ScriptCall = import_bcs.bcs.struct("ScriptCall", {
  code: RawBytes(),
  args: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  typeArgs: import_bcs.bcs.vector(TypeTag)
});
const CallFunction = import_bcs.bcs.struct("FunctionCall", {
  functionId: FunctionId,
  typeArgs: import_bcs.bcs.vector(TypeTag),
  args: import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8()))
});
const MoveAction = enumKind(
  import_bcs.bcs.enum("MoveAction", {
    ScriptCall,
    CallFunction
  })
);
const RoochTransactionData = import_bcs.bcs.struct("RoochTransactionData", {
  sender: Address,
  sequenceNumber: import_bcs.bcs.u64(),
  chainId: import_bcs.bcs.u64(),
  maxGas: import_bcs.bcs.u64(),
  action: MoveAction
});
const Authenticator = import_bcs.bcs.struct("Authenticator", {
  authValidatorId: import_bcs.bcs.u64(),
  payload: import_bcs.bcs.vector(import_bcs.bcs.u8())
});
const RoochTransaction = import_bcs.bcs.struct("RoochTransaction", {
  data: raw(import_bcs.bcs.u8()),
  auth: raw(import_bcs.bcs.u8())
});
//# sourceMappingURL=bcs.js.map
