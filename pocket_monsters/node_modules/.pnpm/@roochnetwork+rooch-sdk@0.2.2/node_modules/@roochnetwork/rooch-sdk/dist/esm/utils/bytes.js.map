{
  "version": 3,
  "sources": ["../../../src/utils/bytes.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Buffer } from 'buffer'\nimport { base16, base32, base58, base58xmr, base64, base64url, hex, utf8 } from '@scure/base'\nimport { Bytes } from '../types/bytes.js'\n\nconst CODERS = {\n  utf8,\n  hex,\n  base16,\n  base32,\n  base64,\n  base64url,\n  base58,\n  base58xmr,\n}\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n  if (a === b) return true\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isBytes(a: unknown): a is Bytes {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  )\n}\n\nexport type CoderType = keyof typeof CODERS\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr'\n\nexport const bytesToString = (type: CoderType, bytes: Bytes): string => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError)\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array')\n  return CODERS[type].encode(bytes)\n}\nexport const str = bytesToString // as in python, but for bytes only\n\nexport const stringToBytes = (type: CoderType, str: string): Bytes => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError)\n  return CODERS[type].decode(str)\n}\n\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i]\n    if (!isBytes(a)) throw new Error('Uint8Array expected')\n    sum += a.length\n  }\n  const res = new Uint8Array(sum)\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i]\n    res.set(a, pad)\n    pad += a.length\n  }\n  return res\n}\n\nexport function varintByteNum(input: number): Bytes {\n  if (input < 253) {\n    let buf = Buffer.alloc(1)\n    buf.writeUInt8(input)\n    return buf\n  } else if (input < 0x10000) {\n    let buf = Buffer.alloc(1 + 2)\n    buf.writeUInt8(253)\n    buf.writeUInt16LE(input, 1)\n    return buf\n  } else if (input < 0x100000000) {\n    let buf = Buffer.alloc(1 + 4)\n    buf.writeUInt8(254)\n    buf.writeUInt32LE(input, 1)\n    return buf\n  } else {\n    let buf = Buffer.alloc(1 + 8)\n    buf.writeUInt8(255)\n    buf.writeInt32LE(input & -1, 1)\n    buf.writeUInt32LE(Math.floor(input / 0x100000000), 5)\n    return buf\n  }\n}\n\n// export class ByteWriter {\n//   value: Bytes\n//\n//   constructor(value: Bytes) {\n//     this.value = value\n//   }\n//\n//   public writeUInt8(input: number) {\n//     if (input < 0) {\n//       input = input >>> 0\n//     }\n//     let buf = Buffer.from(this.value)\n//     buf.writeUInt8(input, this.value.length)\n//\n//     this.value = buf\n//   }\n//\n//   public writeUInt16BE(input: number) {\n//     if (input < 0) {\n//       input = input >>> 0\n//     }\n//\n//     let buf = Buffer.from(this.value)\n//     buf.writeUInt16BE(input, this.value.length)\n//     this.value = buf\n//   }\n//\n//   public varintBufNum(input: number) {\n//     let buf = Buffer.from([])\n//     if (input < 253) {\n//       buf.writeUInt8(input)\n//     } else if (input < 0x10000) {\n//       buf.writeUInt8(253)\n//       buf.writeUInt16LE(input, 1)\n//     } else if (input < 0x100000000) {\n//       buf.writeUInt8(254)\n//       buf.writeUInt32LE(input, 1)\n//     } else {\n//       buf.writeUInt8(255)\n//       buf.writeInt32LE(input & -1, 1)\n//       buf.writeUInt32LE(Math.floor(input / 0x100000000), 5)\n//     }\n//\n//     this.value = concatBytes(this.value, buf)\n//   }\n// }\n\nexport const bytes = stringToBytes\n"],
  "mappings": "AAGA,SAAS,cAAc;AACvB,SAAS,QAAQ,QAAQ,QAAQ,WAAW,QAAQ,WAAW,KAAK,YAAY;AAGhF,MAAM,SAAS;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,SAAS,WAAW,GAAe,GAAe;AACvD,MAAI,MAAM;AAAG,WAAO;AAEpB,MAAI,EAAE,WAAW,EAAE,QAAQ;AACzB,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,QAAI,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG;AACjB,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,QAAQ,GAAwB;AAC9C,SACE,aAAa,cACZ,KAAK,QAAQ,OAAO,MAAM,YAAY,EAAE,YAAY,SAAS;AAElE;AAGA,MAAM,iBACJ;AAEK,MAAM,gBAAgB,CAAC,MAAiBA,WAAyB;AACtE,MAAI,CAAC,OAAO,eAAe,IAAI;AAAG,UAAM,IAAI,UAAU,cAAc;AACpE,MAAI,CAAC,QAAQA,MAAK;AAAG,UAAM,IAAI,UAAU,oCAAoC;AAC7E,SAAO,OAAO,IAAI,EAAE,OAAOA,MAAK;AAClC;AACO,MAAM,MAAM;AAEZ,MAAM,gBAAgB,CAAC,MAAiBC,SAAuB;AACpE,MAAI,CAAC,OAAO,eAAe,IAAI;AAAG,UAAM,IAAI,UAAU,cAAc;AACpE,SAAO,OAAO,IAAI,EAAE,OAAOA,IAAG;AAChC;AAEO,SAAS,eAAe,QAAkC;AAC/D,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,IAAI,OAAO,CAAC;AAClB,QAAI,CAAC,QAAQ,CAAC;AAAG,YAAM,IAAI,MAAM,qBAAqB;AACtD,WAAO,EAAE;AAAA,EACX;AACA,QAAM,MAAM,IAAI,WAAW,GAAG;AAC9B,WAAS,IAAI,GAAG,MAAM,GAAG,IAAI,OAAO,QAAQ,KAAK;AAC/C,UAAM,IAAI,OAAO,CAAC;AAClB,QAAI,IAAI,GAAG,GAAG;AACd,WAAO,EAAE;AAAA,EACX;AACA,SAAO;AACT;AAEO,SAAS,cAAc,OAAsB;AAClD,MAAI,QAAQ,KAAK;AACf,QAAI,MAAM,OAAO,MAAM,CAAC;AACxB,QAAI,WAAW,KAAK;AACpB,WAAO;AAAA,EACT,WAAW,QAAQ,OAAS;AAC1B,QAAI,MAAM,OAAO,MAAM,IAAI,CAAC;AAC5B,QAAI,WAAW,GAAG;AAClB,QAAI,cAAc,OAAO,CAAC;AAC1B,WAAO;AAAA,EACT,WAAW,QAAQ,YAAa;AAC9B,QAAI,MAAM,OAAO,MAAM,IAAI,CAAC;AAC5B,QAAI,WAAW,GAAG;AAClB,QAAI,cAAc,OAAO,CAAC;AAC1B,WAAO;AAAA,EACT,OAAO;AACL,QAAI,MAAM,OAAO,MAAM,IAAI,CAAC;AAC5B,QAAI,WAAW,GAAG;AAClB,QAAI,aAAa,QAAQ,IAAI,CAAC;AAC9B,QAAI,cAAc,KAAK,MAAM,QAAQ,UAAW,GAAG,CAAC;AACpD,WAAO;AAAA,EACT;AACF;AAiDO,MAAM,QAAQ;",
  "names": ["bytes", "str"]
}
