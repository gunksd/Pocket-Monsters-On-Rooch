{
  "version": 3,
  "sources": ["../../../src/address/bitcoin.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bech32, bech32m, createBase58check } from '@scure/base'\n\nimport { bcs } from '../bcs/index.js'\nimport { Bytes } from '../types/index.js'\nimport { blake2b, bytes, sha256, validateWitness } from '../utils/index.js'\n\nimport { Address, ROOCH_ADDRESS_LENGTH } from './address.js'\nimport { RoochAddress } from './rooch.js'\nimport { MultiChainID } from './types.js'\nimport { ThirdPartyAddress } from './thirdparty-address.js'\n\nconst base58check = createBase58check(sha256)\n\nenum BitcoinNetowk {\n  Bitcoin,\n  /// Bitcoin's testnet network.\n  Testnet,\n  /// Bitcoin's signet network.\n  Signet,\n  /// Bitcoin's regtest network.\n  Regtest,\n}\n\nenum BitcoinAddressType {\n  pkh = 0,\n  sh = 1,\n  wpkh = 2,\n  wsh = 2,\n  tr = 2,\n}\n\nexport class BitcoinAddress extends ThirdPartyAddress implements Address {\n  private readonly bytes: Bytes\n  private roochAddress: RoochAddress | undefined\n\n  constructor(input: string) {\n    super(input)\n    let info = this.decode()\n    this.bytes = this.wrapAddress(info.type, info.bytes, info.version)\n  }\n\n  // static fromBytes(input: Bytes) {\n  //   switch (input[0]) {\n  //     case BitcoinAddressType.pkh:\n  //       return ''\n  //     // case: sh = 1,\n  //     case BitcoinAddressType.wpkh:\n  //       bech32m.encode()\n  //   }\n  // }\n\n  toBytes(): Bytes {\n    return bytes('utf8', this.rawAddress)\n  }\n\n  genMultiChainAddress(): Bytes {\n    return bcs.MultiChainAddress.serialize({\n      multiChainId: MultiChainID.Bitcoin,\n      rawAddress: this.bytes,\n    }).toBytes()\n  }\n\n  genRoochAddress(): RoochAddress {\n    if (!this.roochAddress) {\n      this.roochAddress = new RoochAddress(blake2b(this.bytes, { dkLen: ROOCH_ADDRESS_LENGTH }))\n    }\n\n    return this.roochAddress\n  }\n\n  decode() {\n    let input = this.rawAddress\n    if (input.length < 14 || input.length > 74) throw new Error('Invalid address length')\n\n    const bech32_network = (() => {\n      const sep = input.lastIndexOf('1')\n      const bech32Prefix = sep === -1 ? input : input.substring(0, sep)\n\n      switch (bech32Prefix) {\n        case 'bc' || 'BC':\n          return BitcoinNetowk.Bitcoin\n        case 'tb' || 'TB':\n          return BitcoinNetowk.Testnet\n        case 'bcrt' || 'bcrt':\n          return BitcoinNetowk.Regtest\n        default:\n          return undefined\n      }\n    })()\n\n    if (bech32_network !== undefined) {\n      let res\n      try {\n        res = bech32.decode(input)\n        if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`)\n      } catch (_) {\n        // Starting from version 1 it is decoded as bech32m\n        res = bech32m.decode(input)\n        if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`)\n      }\n      const [version, ...program] = res.words\n      const data = bech32.fromWords(program)\n      validateWitness(version, data)\n      if (version === 0 && data.length === 32)\n        return {\n          bytes: data,\n          type: BitcoinAddressType.wsh,\n          version: version,\n        }\n      else if (version === 0 && data.length === 20)\n        return {\n          bytes: data,\n          type: BitcoinAddressType.wpkh,\n          version: version,\n        }\n      else if (version === 1 && data.length === 32)\n        return {\n          bytes: data,\n          type: BitcoinAddressType.tr,\n          version: version,\n        }\n      else throw new Error('Unknown witness program')\n    }\n\n    const data = base58check.decode(input)\n    if (data.length !== 21) throw new Error('Invalid base58 address')\n    // Pay To Public Key Hash\n    if (data[0] === 0x00) {\n      return {\n        bytes: data.slice(1),\n        type: BitcoinAddressType.pkh,\n      }\n    } else if (data[0] === 0x05) {\n      return { bytes: data.slice(1), type: BitcoinAddressType.sh }\n    }\n    throw new Error(`Invalid address prefix=${data[0]}`)\n  }\n\n  private wrapAddress(type: BitcoinAddressType, bytes: Uint8Array, version?: number): Uint8Array {\n    const addr = new Uint8Array(bytes.length + 1 + (version !== undefined ? 1 : 0))\n    addr.set([type])\n    if (version !== undefined) {\n      addr.set([version], 1)\n      addr.set(bytes, 2)\n    } else {\n      addr.set(bytes, 1)\n    }\n    return addr\n  }\n}\n"],
  "mappings": "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",
  "names": ["BitcoinNetowk", "BitcoinAddressType", "data", "bytes"]
}
