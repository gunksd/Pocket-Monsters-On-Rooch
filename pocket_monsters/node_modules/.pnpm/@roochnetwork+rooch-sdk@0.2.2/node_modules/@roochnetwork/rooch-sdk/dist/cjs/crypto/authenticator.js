"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var authenticator_exports = {};
__export(authenticator_exports, {
  Authenticator: () => Authenticator,
  BitcoinSignMessage: () => BitcoinSignMessage,
  BuiltinAuthValidator: () => BuiltinAuthValidator
});
module.exports = __toCommonJS(authenticator_exports);
var import_bcs = require("../bcs/index.js");
var import_utils = require("../utils/index.js");
var import_signatureScheme = require("./signatureScheme.js");
const BitcoinMessagePrefix = "Bitcoin Signed Message:\n";
const MessageInfoPrefix = "Rooch Transaction:\n";
class BitcoinSignMessage {
  constructor(txData, messageInfo) {
    this.messagePrefix = BitcoinMessagePrefix;
    let msg = messageInfo.startsWith(MessageInfoPrefix) ? messageInfo : MessageInfoPrefix + messageInfo;
    msg = msg.charAt(msg.length - 1) !== "\n" ? msg + "\n" : msg;
    this.messageInfo = msg;
    this.txHash = txData;
  }
  raw() {
    return this.messageInfo + (0, import_utils.toHEX)(this.txHash);
  }
  encode() {
    const msgHex = (0, import_utils.bytes)("utf8", (0, import_utils.toHEX)(this.txHash));
    const infoBytes = (0, import_utils.bytes)("utf8", this.messageInfo);
    const prefixBytes = (0, import_utils.concatBytes)(
      (0, import_utils.bytes)("utf8", this.messagePrefix),
      (0, import_utils.varintByteNum)(infoBytes.length + msgHex.length)
    );
    const totalLength = prefixBytes.length + infoBytes.length + msgHex.length;
    const data = new Uint8Array(totalLength);
    let offset = 0;
    data.set(prefixBytes, offset);
    offset += prefixBytes.length;
    data.set(infoBytes, offset);
    offset += infoBytes.length;
    data.set(msgHex, offset);
    return data;
  }
  hash() {
    return (0, import_utils.sha256)(this.encode());
  }
}
var BuiltinAuthValidator = /* @__PURE__ */ ((BuiltinAuthValidator2) => {
  BuiltinAuthValidator2[BuiltinAuthValidator2["ROOCH"] = 0] = "ROOCH";
  BuiltinAuthValidator2[BuiltinAuthValidator2["BITCOIN"] = 1] = "BITCOIN";
  return BuiltinAuthValidator2;
})(BuiltinAuthValidator || {});
class Authenticator {
  constructor(authValidatorId, payload) {
    this.authValidatorId = authValidatorId;
    this.payload = payload;
  }
  encode() {
    return import_bcs.bcs.Authenticator.serialize({
      authValidatorId: this.authValidatorId,
      payload: this.payload
    }).toBytes();
  }
  static async rooch(input, signer) {
    const signature = await signer.sign(input);
    const pubKeyBytes = signer.getPublicKey().toBytes();
    const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
    serializedSignature.set([import_signatureScheme.SIGNATURE_SCHEME_TO_FLAG[signer.getKeyScheme()]]);
    serializedSignature.set(signature, 1);
    serializedSignature.set(signer.getPublicKey().toBytes(), 1 + signature.length);
    return new Authenticator(0 /* ROOCH */, serializedSignature);
  }
  static async bitcoin(input, signer, signWith = "hash") {
    if (!input.messageInfo.startsWith(MessageInfoPrefix)) {
      throw Error("invalid message info");
    }
    const messageLength = (0, import_utils.bytes)("utf8", input.messageInfo).length + (0, import_utils.toHEX)(input.txHash).length;
    const sign = await signer.sign(signWith === "hash" ? input.hash() : (0, import_utils.bytes)("utf8", input.raw()));
    const payload = import_bcs.bcs.BitcoinAuthPayload.serialize({
      signature: sign,
      messagePrefix: (0, import_utils.concatBytes)((0, import_utils.bytes)("utf8", input.messagePrefix), (0, import_utils.varintByteNum)(messageLength)),
      messageInfo: (0, import_utils.bytes)("utf8", input.messageInfo),
      publicKey: signer.getPublicKey().toBytes(),
      fromAddress: (0, import_utils.bytes)("utf8", signer.getBitcoinAddress().toStr())
    }).toBytes();
    return new Authenticator(1 /* BITCOIN */, payload);
  }
}
//# sourceMappingURL=authenticator.js.map
