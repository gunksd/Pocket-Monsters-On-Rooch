// src/provider/clientProvider.tsx
import { useCallback as useCallback2 } from "react";
import { createContext as createContext3, useMemo, useState as useState2 } from "react";
import {
  getRoochNodeUrl,
  isRoochClient,
  RoochClient
} from "@roochnetwork/rooch-sdk";

// src/hooks/useSessionsStore.ts
import { useContext as useContext3 } from "react";
import { useStore as useStore2 } from "zustand";

// src/provider/roochProvider.tsx
import { createContext, useRef } from "react";

// src/provider/sessionStore.ts
import { createStore } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import { Session } from "@roochnetwork/rooch-sdk";

// src/wellet/wallet.ts
import { Signer } from "@roochnetwork/rooch-sdk";

// src/wellet/bitcoin.ts
import {
  Authenticator,
  BitcoinSignMessage,
  Secp256k1PublicKey,
  fromHEX
} from "@roochnetwork/rooch-sdk";

// src/wellet/unisat.ts
import { BitcoinAddress as BitcoinAddress2, str, bytes } from "@roochnetwork/rooch-sdk";

// src/wellet/okx.ts
import { BitcoinAddress as BitcoinAddress3, str as str2, bytes as bytes2 } from "@roochnetwork/rooch-sdk";

// src/wellet/onekey.ts
import { BitcoinAddress as BitcoinAddress4, str as str3, bytes as bytes3 } from "@roochnetwork/rooch-sdk";

// src/provider/roochProvider.tsx
import { jsx } from "react/jsx-runtime";
var RoochContext = createContext(null);

// src/provider/walletProvider.tsx
import { useCallback, createContext as createContext2, useEffect as useEffect2, useRef as useRef2 } from "react";
import { BitcoinAddress as BitcoinAddress5 } from "@roochnetwork/rooch-sdk";

// src/provider/walletStore.ts
import { createStore as createStore2 } from "zustand";
import { createJSONStorage as createJSONStorage2, persist as persist2 } from "zustand/middleware";

// src/hooks/client/useRoochContext.ts
import { useContext } from "react";

// src/hooks/client/useRoochClientQuery.ts
import { useQuery } from "@tanstack/react-query";

// src/hooks/client/useSwitchNetwork.ts
import { useMutation } from "@tanstack/react-query";

// src/constants/roochMutationKeys.ts
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...roochMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var roochMutationKeys = {
  all: { baseScope: "rooch" },
  addNetwork: formMutationKeyFn("add-network"),
  switchNetwork: formMutationKeyFn("switch-network"),
  removeNetwork: formMutationKeyFn("remove-network"),
  removeSession: formMutationKeyFn("remove-session"),
  transferObject: formMutationKeyFn("transfer-object"),
  transferCoin: formMutationKeyFn("transfer-coin"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction")
};

// src/constants/walletMutationKeys.ts
function formMutationKeyFn2(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn2("connect-wallet"),
  autoConnectWallet: formMutationKeyFn2("auto-connect-wallet"),
  switchAccount: formMutationKeyFn2("switch-account"),
  createSessionKey: formMutationKeyFn2("create-session-key")
};

// src/hooks/client/useTransferObject.ts
import { useMutation as useMutation2 } from "@tanstack/react-query";

// src/hooks/client/useTransferCoin.ts
import { useMutation as useMutation3 } from "@tanstack/react-query";

// src/hooks/client/useSignAndExecuteTransaction.ts
import { useMutation as useMutation4 } from "@tanstack/react-query";

// src/hooks/wallet/useWalletStore.ts
import { useContext as useContext2 } from "react";
import { useStore } from "zustand";

// src/hooks/wallet/useAutoConnectWallet.ts
import { useQuery as useQuery2 } from "@tanstack/react-query";
import { useLayoutEffect, useState } from "react";

// src/hooks/wallet/useConnectWallet.ts
import { useMutation as useMutation5 } from "@tanstack/react-query";

// src/hooks/wallet/useWalletCreateSession.ts
import { useMutation as useMutation6 } from "@tanstack/react-query";

// src/hooks/wallet/useWalletChanged.ts
import { useEffect } from "react";

// src/hooks/useRemoveSession.ts
import { useMutation as useMutation7 } from "@tanstack/react-query";

// src/provider/walletProvider.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var WalletContext = createContext2(null);

// src/hooks/useSessionsStore.ts
function useSessionStore(selector) {
  const store = useContext3(RoochContext);
  if (!store) {
    throw new Error(
      "Could not find RoochSessionContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return useStore2(store, selector);
}

// src/http/httpTransport.ts
import {
  RoochHTTPTransport,
  ErrorValidateInvalidAccountAuthKey,
  ErrorValidateSessionIsExpired
} from "@roochnetwork/rooch-sdk";
var HTTPTransport = class extends RoochHTTPTransport {
  constructor(options, sessionExpiredCallback) {
    super(options);
    this.sessionExpiredCallback = sessionExpiredCallback;
  }
  async request(input) {
    let result;
    try {
      result = await super.request(input);
      return result;
    } catch (e) {
      if ("code" in e && (e.code === ErrorValidateInvalidAccountAuthKey || e.code === ErrorValidateSessionIsExpired)) {
        this.sessionExpiredCallback();
      }
      throw e;
    }
  }
};

// src/provider/clientProvider.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var ClientContext = createContext3(null);
var DEFAULT_NETWORKS = {
  localnet: { url: getRoochNodeUrl("localnet") }
};
var DEFAULT_CREATE_CLIENT = function createClient(_name, config, setCurrentSession) {
  if (isRoochClient(config)) {
    return config;
  }
  config.transport = new HTTPTransport(
    {
      url: config.url.toString()
    },
    setCurrentSession
  );
  return new RoochClient(config);
};
function RoochClientProvider(props) {
  const { onNetworkChange, network, children } = props;
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const networks = props.networks ?? DEFAULT_NETWORKS;
  const [selectedNetwork, setSelectedNetwork] = useState2(
    props.network ?? props.defaultNetwork ?? Object.keys(networks)[0]
  );
  const currentNetwork = props.network ?? selectedNetwork;
  const clearSession = useCallback2(() => {
    try {
      setCurrentSession(void 0);
    } catch (e) {
      console.log(e);
    }
  }, [setCurrentSession]);
  const client = useMemo(() => {
    return DEFAULT_CREATE_CLIENT(currentNetwork, networks[currentNetwork], () => {
      clearSession();
    });
  }, [currentNetwork, networks, clearSession]);
  const ctx = useMemo(() => {
    return {
      client,
      network: currentNetwork,
      networks,
      config: networks[currentNetwork] instanceof RoochClient ? null : networks[currentNetwork],
      selectNetwork: (newNetwork) => {
        if (currentNetwork === newNetwork) {
          return;
        }
        if (!network && newNetwork !== selectedNetwork) {
          setSelectedNetwork(newNetwork);
        }
        onNetworkChange?.(newNetwork);
      }
    };
  }, [client, currentNetwork, networks, network, selectedNetwork, onNetworkChange]);
  return /* @__PURE__ */ jsx3(ClientContext.Provider, { value: ctx, children });
}
export {
  ClientContext,
  RoochClientProvider
};
//# sourceMappingURL=clientProvider.js.map
