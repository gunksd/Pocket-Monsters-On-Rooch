// src/hooks/client/useCurrentNetwork.ts
function useCurrentNetwork() {
  return useRoochContext().network;
}

// src/hooks/client/useRoochContext.ts
import { useContext as useContext2 } from "react";

// src/provider/clientProvider.tsx
import { useCallback as useCallback2 } from "react";
import { createContext as createContext3, useMemo, useState } from "react";
import {
  getRoochNodeUrl,
  isRoochClient,
  RoochClient
} from "@roochnetwork/rooch-sdk";

// src/hooks/useSessionsStore.ts
import { useContext } from "react";
import { useStore } from "zustand";

// src/provider/roochProvider.tsx
import { createContext, useRef } from "react";

// src/provider/sessionStore.ts
import { createStore } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import { Session } from "@roochnetwork/rooch-sdk";

// src/wellet/wallet.ts
import { Signer } from "@roochnetwork/rooch-sdk";

// src/wellet/bitcoin.ts
import {
  Authenticator,
  BitcoinSignMessage,
  Secp256k1PublicKey,
  fromHEX
} from "@roochnetwork/rooch-sdk";

// src/wellet/unisat.ts
import { BitcoinAddress as BitcoinAddress2, str, bytes } from "@roochnetwork/rooch-sdk";

// src/wellet/okx.ts
import { BitcoinAddress as BitcoinAddress3, str as str2, bytes as bytes2 } from "@roochnetwork/rooch-sdk";

// src/wellet/onekey.ts
import { BitcoinAddress as BitcoinAddress4, str as str3, bytes as bytes3 } from "@roochnetwork/rooch-sdk";

// src/provider/roochProvider.tsx
import { jsx } from "react/jsx-runtime";
var RoochContext = createContext(null);

// src/provider/walletProvider.tsx
import { useCallback, createContext as createContext2, useEffect, useRef as useRef2 } from "react";
import { BitcoinAddress as BitcoinAddress5 } from "@roochnetwork/rooch-sdk";

// src/provider/walletStore.ts
import { createStore as createStore2 } from "zustand";
import { createJSONStorage as createJSONStorage2, persist as persist2 } from "zustand/middleware";

// src/wellet/wallets.ts
var wallets = void 0;
var registered = /* @__PURE__ */ new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  return wallets;
}
function register(...wallets2) {
  wallets2.forEach((wallet) => registered.add(wallet));
  listeners["register"]?.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    wallets2.forEach((wallet) => registered.delete(wallet));
    listeners["unregister"]?.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get() {
  return [...registered];
}
function on(event, listener) {
  listeners[event]?.push(listener) || (listeners[event] = [listener]);
  return function off() {
    listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}

// src/wellet/util.ts
function getRegisteredWallets(preferredWallets, walletFilter) {
  const walletsApi = getWallets();
  const wallets2 = walletsApi.get();
  const Wallets = wallets2.filter((wallet) => !walletFilter || walletFilter(wallet));
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => Wallets.find((wallet) => wallet.getName() === name)),
    // Wallets in default order:
    ...Wallets.filter((wallet) => !preferredWallets.includes(wallet.getName()))
  ].filter((wallet) => wallet !== void 0);
}

// src/provider/walletProvider.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var WalletContext = createContext2(null);

// src/hooks/useSessionsStore.ts
function useSessionStore(selector) {
  const store = useContext(RoochContext);
  if (!store) {
    throw new Error(
      "Could not find RoochSessionContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return useStore(store, selector);
}

// src/http/httpTransport.ts
import {
  RoochHTTPTransport,
  ErrorValidateInvalidAccountAuthKey,
  ErrorValidateSessionIsExpired
} from "@roochnetwork/rooch-sdk";

// src/provider/clientProvider.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var ClientContext = createContext3(null);
var DEFAULT_NETWORKS = {
  localnet: { url: getRoochNodeUrl("localnet") }
};

// src/hooks/client/useRoochContext.ts
function useRoochContext() {
  const context = useContext2(ClientContext);
  if (!context) {
    throw new Error(
      "Could not find RoochClientContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return context;
}

// src/hooks/client/useRoochClient.ts
function useRoochClient() {
  return useRoochContext().client;
}

// src/hooks/client/useRoochClientQuery.ts
import { useQuery } from "@tanstack/react-query";
function useRoochClientQuery(...args) {
  const [method, params, { queryKey = [], ...options } = {}] = args;
  const network = useCurrentNetwork();
  const roochClient = useRoochClient();
  return useQuery({
    ...options,
    queryKey: [network, method, params, ...queryKey],
    queryFn: async () => {
      return await roochClient[method](params);
    }
  });
}

// src/hooks/client/useSwitchNetwork.ts
import { useMutation } from "@tanstack/react-query";

// src/constants/roochMutationKeys.ts
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...roochMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var roochMutationKeys = {
  all: { baseScope: "rooch" },
  addNetwork: formMutationKeyFn("add-network"),
  switchNetwork: formMutationKeyFn("switch-network"),
  removeNetwork: formMutationKeyFn("remove-network"),
  removeSession: formMutationKeyFn("remove-session"),
  transferObject: formMutationKeyFn("transfer-object"),
  transferCoin: formMutationKeyFn("transfer-coin"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction")
};

// src/constants/walletMutationKeys.ts
function formMutationKeyFn2(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn2("connect-wallet"),
  autoConnectWallet: formMutationKeyFn2("auto-connect-wallet"),
  switchAccount: formMutationKeyFn2("switch-account"),
  createSessionKey: formMutationKeyFn2("create-session-key")
};

// src/hooks/client/useSwitchNetwork.ts
function useSwitchNetwork({
  mutationKey,
  ...mutationOptions
} = {}) {
  const switchNetwork = useRoochContext().selectNetwork;
  return useMutation({
    mutationKey: roochMutationKeys.switchNetwork(mutationKey),
    mutationFn: async (args) => {
      switchNetwork(args);
    },
    ...mutationOptions
  });
}

// src/hooks/client/useTransferObject.ts
import { useMutation as useMutation2 } from "@tanstack/react-query";
function useTransferObject({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  return useMutation2({
    mutationKey: roochMutationKeys.transferObject(mutationKey),
    mutationFn: async (args) => {
      const result = await client.transferObject(args);
      if (result.execution_info.status.type !== "executed") {
        Error("transfer failed" + result.execution_info.status.type);
      }
    },
    ...mutationOptions
  });
}

// src/hooks/client/useTransferCoin.ts
import { useMutation as useMutation3 } from "@tanstack/react-query";

// src/hooks/useCurrentSession.ts
function useCurrentSession() {
  return useSessionStore((state) => state.currentSession);
}

// src/hooks/client/useTransferCoin.ts
function useTransferCoin({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const curSession = useCurrentSession();
  return useMutation3({
    mutationKey: roochMutationKeys.transferCoin(mutationKey),
    mutationFn: async (args) => {
      const signer = args.signer || curSession;
      if (signer === null) {
        throw Error("");
      }
      const result = await client.transfer({
        ...args,
        signer: args.signer || curSession
      });
      if (result.execution_info.status.type !== "executed") {
        Error("transfer failed" + result.execution_info.status.type);
      }
    },
    ...mutationOptions
  });
}

// src/hooks/client/networks-config.ts
function createNetworkConfig(networkConfig) {
  function useNetworkConfig() {
    const { config } = useRoochContext();
    if (!config) {
      throw new Error("No network config found");
    }
    return config;
  }
  function useNetworkVariables() {
    const { variables } = useNetworkConfig();
    return variables ?? {};
  }
  function useNetworkVariable(name) {
    const variables = useNetworkVariables();
    return variables[name];
  }
  return {
    networkConfig,
    useNetworkConfig,
    useNetworkVariables,
    useNetworkVariable
  };
}

// src/hooks/client/useSignAndExecuteTransaction.ts
import { useMutation as useMutation4 } from "@tanstack/react-query";
function UseSignAndExecuteTransaction({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const session = useCurrentSession();
  return useMutation4({
    mutationKey: roochMutationKeys.signAndExecuteTransaction(mutationKey),
    mutationFn: async (args) => {
      if (!session) {
        throw Error("Create a session first");
      }
      const result = await client.signAndExecuteTransaction({
        transaction: args.transaction,
        signer: args.signer || session
      });
      if (result.execution_info.status.type !== "executed" && result.execution_info.status) {
        Error("transfer failed" + result.execution_info.status.type);
      }
      return result;
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useWalletStore.ts
import { useContext as useContext3 } from "react";
import { useStore as useStore2 } from "zustand";
function useWalletStore(selector) {
  const store = useContext3(WalletContext);
  if (!store) {
    throw new Error("Could not find WalletContext. Ensure that you have set up the WalletProvider.");
  }
  return useStore2(store, selector);
}

// src/hooks/wallet/useAddresses.ts
function useAddresses() {
  return useWalletStore((state) => state.addresses);
}

// src/hooks/wallet/useAutoConnectWallet.ts
import { useQuery as useQuery2 } from "@tanstack/react-query";
import { useLayoutEffect, useState as useState2 } from "react";
function useAutoConnectWallet() {
  const { mutateAsync: connectWallet } = useConnectWallet();
  const autoConnectEnabled = useWalletStore((state) => state.autoConnectEnabled);
  const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);
  const lastConnectedAddress = useWalletStore((state) => state.lastConnectedAddress);
  const { isConnected } = useCurrentWallet();
  const wallets2 = useWallets();
  const [clientOnly, setClientOnly] = useState2(false);
  const currentAddress = useCurrentAddress();
  useLayoutEffect(() => {
    setClientOnly(true);
  }, []);
  const { data, isError } = useQuery2({
    queryKey: [
      "@rooch/sdk-kit",
      "autoconnect",
      {
        isConnected,
        autoConnectEnabled,
        lastConnectedWalletName,
        lastConnectedAddress
      }
    ],
    queryFn: async () => {
      if (!autoConnectEnabled) {
        return "disabled";
      }
      if (!lastConnectedWalletName || !lastConnectedAddress || isConnected) {
        return "attempted";
      }
      let wallet = wallets2.find((wallet2) => wallet2.getName() === lastConnectedWalletName);
      if (wallet) {
        await connectWallet({ wallet });
        if (wallet.getChain() !== "bitcoin" && currentAddress?.toStr() !== lastConnectedAddress) {
          wallet.switchAccount(lastConnectedAddress);
        }
      }
      return "attempted";
    },
    enabled: autoConnectEnabled,
    persister: void 0,
    gcTime: 0,
    staleTime: 0,
    networkMode: "always",
    retry: (failureCount) => {
      if (wallets2.find((wallet) => wallet.getName() === lastConnectedWalletName) && failureCount < 3) {
        return true;
      }
      return false;
    },
    retryOnMount: false,
    refetchInterval: 1e3,
    refetchIntervalInBackground: false,
    refetchOnMount: false,
    refetchOnReconnect: false,
    refetchOnWindowFocus: false
  });
  if (!autoConnectEnabled) {
    return "disabled";
  }
  if (!clientOnly) {
    return "idle";
  }
  if (!lastConnectedWalletName) {
    return "attempted";
  }
  return isError ? "attempted" : data ?? "idle";
}

// src/hooks/wallet/useConnectWallet.ts
import { useMutation as useMutation5 } from "@tanstack/react-query";

// src/hooks/useSessions.ts
function useSession() {
  return useSessionStore(
    (state) => state.sessions.sort((a, b) => b.getCreateTime() - a.getCreateTime())
  );
}

// src/hooks/wallet/useConnectWallet.ts
function useConnectWallet({
  mutationKey,
  ...mutationOptions
} = {}) {
  const sessions = useSession();
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const setWalletConnected = useWalletStore((state) => state.setWalletConnected);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  return useMutation5({
    mutationKey: walletMutationKeys.connectWallet(mutationKey),
    mutationFn: async ({ wallet }) => {
      try {
        setConnectionStatus("connecting");
        const connectAddress = await wallet.connect();
        const selectedAddress = connectAddress[0];
        setWalletConnected(wallet, connectAddress, selectedAddress);
        const cur = sessions.find(
          (item) => item.getRoochAddress().toStr() === selectedAddress?.genRoochAddress().toStr()
        );
        setCurrentSession(cur);
        return connectAddress;
      } catch (error) {
        setConnectionStatus("disconnected");
        throw error;
      }
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useCurrentAccount.ts
function useCurrentAddress() {
  return useWalletStore((state) => state.currentAddress);
}

// src/hooks/wallet/useCurrentWallet.ts
function useCurrentWallet() {
  const currentWallet = useWalletStore((state) => state.currentWallet);
  const connectionStatus = useWalletStore((state) => state.connectionStatus);
  switch (connectionStatus) {
    case "connecting":
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: false,
        isConnecting: true,
        isConnected: false
      };
    case "disconnected":
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: true,
        isConnecting: false,
        isConnected: false
      };
    case "connected": {
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: false,
        isConnecting: false,
        isConnected: true
      };
    }
  }
}

// src/hooks/wallet/useWalletCreateSession.ts
import { useMutation as useMutation6 } from "@tanstack/react-query";

// src/error/walletErrors.ts
var WalletNotConnectedError = class extends Error {
};

// src/hooks/wallet/useWalletCreateSession.ts
function useCreateSessionKey({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const currentWallet = useCurrentWallet();
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  return useMutation6({
    mutationKey: walletMutationKeys.createSessionKey(mutationKey),
    mutationFn: async (args) => {
      if (!currentWallet.isConnected) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      const sessionAccount = await client.createSession({
        signer: currentWallet.wallet,
        sessionArgs: args
      });
      setCurrentSession(sessionAccount);
      return sessionAccount;
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useWallets.ts
function useWallets() {
  return useWalletStore((state) => state.wallets);
}

// src/hooks/wallet/useWalletChanged.ts
import { useEffect as useEffect2 } from "react";
function useWalletChanged(preferredWallets, walletFilter) {
  const updateWallets = useWalletStore((state) => state.updateWallets);
  useEffect2(() => {
    const api = getWallets();
    updateWallets(getRegisteredWallets(preferredWallets, walletFilter));
    const unsubscribeFromRegister = api.on("register", () => {
      updateWallets(getRegisteredWallets(preferredWallets, walletFilter));
    });
    return () => {
      unsubscribeFromRegister();
    };
  }, [preferredWallets, updateWallets, walletFilter]);
}

// src/hooks/useRemoveSession.ts
import { useMutation as useMutation7 } from "@tanstack/react-query";
function useRemoveSession({
  mutationKey,
  ...mutationOptions
} = {}) {
  const sessionsKeys = useSession();
  const removeSession = useSessionStore((state) => state.removeSession);
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const currentSession = useCurrentSession();
  const client = useRoochClient();
  const curSessionKey = useCurrentSession();
  return useMutation7({
    mutationKey: roochMutationKeys.removeSession(mutationKey),
    mutationFn: async (args) => {
      try {
        if (!curSessionKey) {
          return;
        }
        const result = await client.removeSession({
          authKey: args.authKey,
          signer: curSessionKey
        });
        if (result) {
          let cacheSession = sessionsKeys.find(
            (item) => item.getAuthKey() === args.authKey
          );
          if (cacheSession) {
            removeSession(cacheSession);
            if (cacheSession.getAuthKey() === currentSession?.getAuthKey()) {
              setCurrentSession(void 0);
            }
          }
        }
      } catch (e) {
        throw e;
      }
    },
    ...mutationOptions
  });
}
export {
  UseSignAndExecuteTransaction,
  createNetworkConfig,
  useAddresses,
  useAutoConnectWallet,
  useConnectWallet,
  useCreateSessionKey,
  useCurrentAddress,
  useCurrentNetwork,
  useCurrentSession,
  useCurrentWallet,
  useRemoveSession,
  useRoochClient,
  useRoochClientQuery,
  useRoochContext,
  useSession,
  useSwitchNetwork,
  useTransferCoin,
  useTransferObject,
  useWalletChanged,
  useWalletStore,
  useWallets
};
//# sourceMappingURL=index.js.map
