"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BitcoinWallet: () => BitcoinWallet,
  OkxWallet: () => OkxWallet,
  OnekeyWallet: () => OnekeyWallet,
  RoochContext: () => RoochContext,
  RoochProvider: () => RoochProvider,
  UniSatWallet: () => UniSatWallet,
  UseSignAndExecuteTransaction: () => UseSignAndExecuteTransaction,
  Wallet: () => Wallet,
  WalletContext: () => WalletContext,
  WalletProvider: () => WalletProvider,
  createNetworkConfig: () => createNetworkConfig,
  useAddresses: () => useAddresses,
  useAutoConnectWallet: () => useAutoConnectWallet,
  useConnectWallet: () => useConnectWallet,
  useCreateSessionKey: () => useCreateSessionKey,
  useCurrentAddress: () => useCurrentAddress,
  useCurrentNetwork: () => useCurrentNetwork,
  useCurrentSession: () => useCurrentSession,
  useCurrentWallet: () => useCurrentWallet,
  useRemoveSession: () => useRemoveSession,
  useRoochClient: () => useRoochClient,
  useRoochClientQuery: () => useRoochClientQuery,
  useRoochContext: () => useRoochContext,
  useSession: () => useSession,
  useSwitchNetwork: () => useSwitchNetwork,
  useTransferCoin: () => useTransferCoin,
  useTransferObject: () => useTransferObject,
  useWalletChanged: () => useWalletChanged,
  useWalletStore: () => useWalletStore,
  useWallets: () => useWallets
});
module.exports = __toCommonJS(src_exports);

// src/provider/roochProvider.tsx
var import_react4 = require("react");

// src/provider/clientProvider.tsx
var import_react2 = require("react");
var import_react3 = require("react");
var import_rooch_sdk2 = require("@roochnetwork/rooch-sdk");

// src/hooks/useSessionsStore.ts
var import_react = require("react");
var import_zustand = require("zustand");
function useSessionStore(selector) {
  const store = (0, import_react.useContext)(RoochContext);
  if (!store) {
    throw new Error(
      "Could not find RoochSessionContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return (0, import_zustand.useStore)(store, selector);
}

// src/http/httpTransport.ts
var import_rooch_sdk = require("@roochnetwork/rooch-sdk");
var HTTPTransport = class extends import_rooch_sdk.RoochHTTPTransport {
  constructor(options, sessionExpiredCallback) {
    super(options);
    this.sessionExpiredCallback = sessionExpiredCallback;
  }
  async request(input) {
    let result;
    try {
      result = await super.request(input);
      return result;
    } catch (e) {
      if ("code" in e && (e.code === import_rooch_sdk.ErrorValidateInvalidAccountAuthKey || e.code === import_rooch_sdk.ErrorValidateSessionIsExpired)) {
        this.sessionExpiredCallback();
      }
      throw e;
    }
  }
};

// src/provider/clientProvider.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var ClientContext = (0, import_react3.createContext)(null);
var DEFAULT_NETWORKS = {
  localnet: { url: (0, import_rooch_sdk2.getRoochNodeUrl)("localnet") }
};
var DEFAULT_CREATE_CLIENT = function createClient(_name, config, setCurrentSession) {
  if ((0, import_rooch_sdk2.isRoochClient)(config)) {
    return config;
  }
  config.transport = new HTTPTransport(
    {
      url: config.url.toString()
    },
    setCurrentSession
  );
  return new import_rooch_sdk2.RoochClient(config);
};
function RoochClientProvider(props) {
  const { onNetworkChange, network, children } = props;
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const networks = props.networks ?? DEFAULT_NETWORKS;
  const [selectedNetwork, setSelectedNetwork] = (0, import_react3.useState)(
    props.network ?? props.defaultNetwork ?? Object.keys(networks)[0]
  );
  const currentNetwork = props.network ?? selectedNetwork;
  const clearSession = (0, import_react2.useCallback)(() => {
    try {
      setCurrentSession(void 0);
    } catch (e) {
      console.log(e);
    }
  }, [setCurrentSession]);
  const client = (0, import_react3.useMemo)(() => {
    return DEFAULT_CREATE_CLIENT(currentNetwork, networks[currentNetwork], () => {
      clearSession();
    });
  }, [currentNetwork, networks, clearSession]);
  const ctx = (0, import_react3.useMemo)(() => {
    return {
      client,
      network: currentNetwork,
      networks,
      config: networks[currentNetwork] instanceof import_rooch_sdk2.RoochClient ? null : networks[currentNetwork],
      selectNetwork: (newNetwork) => {
        if (currentNetwork === newNetwork) {
          return;
        }
        if (!network && newNetwork !== selectedNetwork) {
          setSelectedNetwork(newNetwork);
        }
        onNetworkChange?.(newNetwork);
      }
    };
  }, [client, currentNetwork, networks, network, selectedNetwork, onNetworkChange]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ClientContext.Provider, { value: ctx, children });
}

// src/provider/sessionStore.ts
var import_zustand2 = require("zustand");
var import_middleware = require("zustand/middleware");
var import_rooch_sdk3 = require("@roochnetwork/rooch-sdk");
function createSessionStore({ storage, storageKey }) {
  return (0, import_zustand2.createStore)()(
    (0, import_middleware.persist)(
      (set, get2) => ({
        sessions: [],
        currentSession: null,
        addSession(session) {
          const cache = get2().sessions;
          cache.push(session);
          set(() => ({
            sessions: cache
          }));
        },
        setCurrentSession(session) {
          if (!session) {
            set(() => ({
              currentSession: null
            }));
          } else {
            const cache = get2().sessions;
            if (!cache.find((item) => item.getAuthKey() === session.getAuthKey())) {
              cache.push(session);
            }
            set(() => ({
              currentSession: session,
              sessions: cache
            }));
          }
        },
        removeSession(session) {
          const cacheSessions = get2().sessions;
          const cacheCurSession = get2().currentSession;
          set(() => ({
            currentSession: cacheCurSession?.getAuthKey() === session.getAuthKey() ? null : cacheCurSession,
            sessions: cacheSessions.filter((c) => c.getAuthKey() !== session.getAuthKey())
          }));
        }
      }),
      {
        name: storageKey,
        storage: (0, import_middleware.createJSONStorage)(() => storage, {
          reviver: (key, value) => {
            if (key === "sessions") {
              return value.map((session) => import_rooch_sdk3.Session.fromJson(session));
            }
            return value;
          }
        }),
        partialize: ({ sessions }) => ({
          sessions
        })
      }
    )
  );
}

// src/utils/stateStorage.ts
function createInMemoryStore() {
  const store = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return store.get(key);
    },
    setItem(key, value) {
      store.set(key, value);
    },
    removeItem(key) {
      store.delete(key);
    }
  };
}
function getDefaultStorage(type) {
  let storage;
  switch (type) {
    case 0 /* Session */:
      storage = typeof window !== "undefined" && window.sessionStorage ? sessionStorage : void 0;
      break;
    case 1 /* Local */:
      storage = typeof window !== "undefined" && window.localStorage ? localStorage : void 0;
  }
  if (!storage) {
    storage = createInMemoryStore();
  }
  return storage;
}

// src/wellet/wallet.ts
var import_rooch_sdk4 = require("@roochnetwork/rooch-sdk");
var Wallet = class extends import_rooch_sdk4.Signer {
  /**
   * Checks if the wallet is installed.
   * @returns A promise that resolves to true if the wallet is installed, otherwise false.
   */
  async checkInstalled() {
    for (let i = 1; i < 10 && !this.getTarget(); i += 1) {
      await new Promise((resolve) => setTimeout(resolve, 100 * i));
    }
    return Promise.resolve(this.getTarget() !== void 0);
  }
};

// src/wellet/bitcoin.ts
var import_rooch_sdk5 = require("@roochnetwork/rooch-sdk");
var BitcoinWallet = class extends Wallet {
  async signTransaction(input) {
    const message = new import_rooch_sdk5.BitcoinSignMessage(input.hashData(), input.getInfo() || "");
    return import_rooch_sdk5.Authenticator.bitcoin(message, this, "raw");
  }
  getPublicKey() {
    if (!this.publicKey) {
      throw Error("Please connect your wallet first");
    }
    return new import_rooch_sdk5.Secp256k1PublicKey((0, import_rooch_sdk5.fromHEX)(this.publicKey));
  }
  getRoochAddress() {
    if (!this.currentAddress) {
      throw Error("Please connect your wallet first");
    }
    return this.currentAddress.genRoochAddress();
  }
  getBitcoinAddress() {
    if (!this.currentAddress) {
      throw Error("Please connect your wallet first");
    }
    return this.currentAddress;
  }
  getKeyScheme() {
    return "Secp256k1";
  }
  normalize_recovery_id(v) {
    let normalizeV = v - 27 - 4;
    if (normalizeV < 0) {
      normalizeV = normalizeV + 4;
    }
    return normalizeV;
  }
  switchAccount() {
    throw new Error("Method not implemented.");
  }
  getChain() {
    return "bitcoin";
  }
};

// src/wellet/unisat.ts
var import_rooch_sdk6 = require("@roochnetwork/rooch-sdk");
var UNISAT_SUPPORT_NETWORKS = ["livenet", "testnet"];
var UniSatWallet = class extends BitcoinWallet {
  getName() {
    return "unisat";
  }
  getTarget() {
    return window.unisat;
  }
  async connect() {
    let addresses = await this.getTarget().getAccounts();
    if (!addresses || addresses.length === 0) {
      await this.getTarget().requestAccounts();
      return this.connect();
    }
    let publicKey = await this.getTarget().getPublicKey();
    this.address = addresses.map((item) => new import_rooch_sdk6.BitcoinAddress(item));
    this.currentAddress = this.address[0];
    this.publicKey = publicKey;
    return this.address;
  }
  switchNetwork(network) {
    this.getTarget().switchNetwork(network);
  }
  getNetwork() {
    return this.getTarget().getNetwork();
  }
  getSupportNetworks() {
    return UNISAT_SUPPORT_NETWORKS;
  }
  onAccountsChanged(callback) {
    this.getTarget().on("accountsChanged", callback);
  }
  removeAccountsChanged(callback) {
    this.getTarget().removeListener("accountsChanged", callback);
  }
  onNetworkChanged(callback) {
    this.getTarget().on("networkChanged", callback);
  }
  removeNetworkChanged(callback) {
    this.getTarget().removeListener("networkChanged", callback);
  }
  async sign(msg) {
    const msgStr = (0, import_rooch_sdk6.str)("utf8", msg);
    const sign = await this.getTarget().signMessage(msgStr);
    return (0, import_rooch_sdk6.bytes)("base64", sign).subarray(1);
  }
};

// src/wellet/okx.ts
var import_rooch_sdk7 = require("@roochnetwork/rooch-sdk");
var OkxWallet = class extends BitcoinWallet {
  getName() {
    return "okx";
  }
  async sign(msg) {
    const msgStr = (0, import_rooch_sdk7.str)("utf8", msg);
    const sign = await this.getTarget().signMessage(msgStr, {
      from: this.currentAddress?.toStr()
    });
    return (0, import_rooch_sdk7.bytes)("base64", sign).subarray(1);
  }
  getTarget() {
    return window.okxwallet?.bitcoin;
  }
  async connect() {
    const obj = await this.getTarget().connect();
    this.currentAddress = new import_rooch_sdk7.BitcoinAddress(obj.address);
    this.publicKey = obj.compressedPublicKey !== "" ? obj.compressedPublicKey : obj.publicKey;
    this.address = [this.currentAddress];
    return this.address;
  }
  switchNetwork() {
    this.getTarget().switchNetwork();
  }
  getNetwork() {
    return this.getTarget().getNetwork();
  }
  getSupportNetworks() {
    return ["livenet"];
  }
  onAccountsChanged(callback) {
    this.getTarget().on("accountsChanged", callback);
  }
  removeAccountsChanged(callback) {
    this.getTarget().removeListener("accountsChanged", callback);
  }
  onNetworkChanged(callback) {
    this.getTarget().on("networkChanged", callback);
  }
  removeNetworkChanged(callback) {
    this.getTarget().removeListener("networkChanged", callback);
  }
};

// src/wellet/onekey.ts
var import_rooch_sdk8 = require("@roochnetwork/rooch-sdk");
var OnekeyWallet = class extends BitcoinWallet {
  getName() {
    return "onekey";
  }
  async sign(msg) {
    const msgStr = (0, import_rooch_sdk8.str)("utf8", msg);
    const sign = await this.getTarget().signMessage(msgStr);
    return (0, import_rooch_sdk8.bytes)("base64", sign).subarray(1);
  }
  getTarget() {
    return window.$onekey?.btc;
  }
  async connect() {
    let addresses = await this.getTarget().getAccounts();
    if (!addresses || addresses.length === 0) {
      await this.getTarget().requestAccounts();
      return this.connect();
    }
    let publicKey = await this.getTarget().getPublicKey();
    this.address = addresses.map((item) => new import_rooch_sdk8.BitcoinAddress(item));
    this.currentAddress = this.address[0];
    this.publicKey = publicKey;
    return this.address;
  }
  switchNetwork() {
    this.getTarget().switchNetwork();
  }
  getNetwork() {
    return this.getTarget().getNetwork();
  }
  getSupportNetworks() {
    return ["livenet"];
  }
  onAccountsChanged(callback) {
    this.getTarget().on("accountsChanged", callback);
  }
  removeAccountsChanged(callback) {
    this.getTarget().removeListener("accountsChanged", callback);
  }
  onNetworkChanged(callback) {
    this.getTarget().on("networkChanged", callback);
  }
  removeNetworkChanged(callback) {
    this.getTarget().removeListener("networkChanged", callback);
  }
};

// src/utils/walletUtils.ts
async function checkWallets(filter) {
  const wallets2 = [
    new UniSatWallet()
    // new OkxWallet(),
    // new OnekeyWallet(),
    // new OnekeyHardwareWallet(),
  ].filter((wallet) => wallet.getChain() === filter || !filter);
  return await Promise.all(wallets2.filter(async (w) => await w.checkInstalled()));
}

// src/provider/roochProvider.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var DEFAULT_SESSION_STORAGE_KEY = function(_) {
  return "rooch-sdk-kit:rooch-session-info";
};
var RoochContext = (0, import_react4.createContext)(null);
function RoochProvider(props) {
  const { children, networks, defaultNetwork } = props;
  const storeRef = (0, import_react4.useRef)(
    createSessionStore({
      storage: getDefaultStorage(1 /* Local */),
      storageKey: DEFAULT_SESSION_STORAGE_KEY()
    })
  );
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RoochContext.Provider, { value: storeRef.current, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RoochClientProvider, { networks, defaultNetwork, children }) });
}

// src/provider/walletProvider.tsx
var import_react9 = require("react");
var import_rooch_sdk9 = require("@roochnetwork/rooch-sdk");

// src/provider/walletStore.ts
var import_zustand3 = require("zustand");
var import_middleware2 = require("zustand/middleware");
function createWalletStore({
  chain,
  currentWallet,
  wallets: wallets2,
  storage,
  storageKey,
  autoConnectEnabled
}) {
  return (0, import_zustand3.createStore)()(
    (0, import_middleware2.persist)(
      (set, get2) => ({
        currentChain: chain,
        autoConnectEnabled,
        currentWallet,
        wallets: wallets2,
        addresses: [],
        currentAddress: void 0,
        lastConnectedAddress: void 0,
        lastConnectedWalletName: void 0,
        connectionStatus: "disconnected",
        setChain(chain2) {
          const currentChain = get2().currentChain;
          if (currentChain === chain2) {
            return;
          }
          set(() => ({
            currentChain: chain2,
            accounts: [],
            // currentWallet: supportWallets.find((v) => v.getSupportNetworks()),
            sessionAccount: null,
            connectionStatus: "disconnected"
          }));
        },
        setConnectionStatus(connectionStatus) {
          set(() => ({
            connectionStatus
          }));
        },
        setWalletConnected(wallet, connectedAddresses, selectedAddress) {
          set(() => ({
            currentWallet: wallet,
            accounts: connectedAddresses,
            currentAddress: selectedAddress || void 0,
            lastConnectedWalletName: wallet.getName(),
            lastConnectedAddress: selectedAddress?.toStr(),
            connectionStatus: "connected"
          }));
        },
        setWalletDisconnected() {
          set(() => ({
            accounts: [],
            currentAddress: void 0,
            lastConnectedWalletName: void 0,
            lastConnectedAddress: void 0,
            connectionStatus: "disconnected"
          }));
        },
        setAddressSwitched(selected) {
          set(() => ({
            currentAddress: selected,
            lastConnectedAddress: selected.toStr() ?? ""
          }));
        },
        updateWalletAddresses(addresses) {
          const currentAddr = get2().currentAddress;
          set(() => ({
            currentAddress: currentAddr && addresses.find((addr) => addr.toStr() === currentAddr.toStr()) || addresses[0]
          }));
        },
        updateWallets(wallets3) {
          set(() => ({
            wallets: wallets3
          }));
        }
      }),
      {
        name: storageKey,
        storage: (0, import_middleware2.createJSONStorage)(() => storage),
        partialize: ({ lastConnectedWalletName, lastConnectedAddress }) => ({
          lastConnectedWalletName,
          lastConnectedAddress
        })
      }
    )
  );
}

// src/hooks/client/useCurrentNetwork.ts
function useCurrentNetwork() {
  return useRoochContext().network;
}

// src/hooks/client/useRoochContext.ts
var import_react5 = require("react");
function useRoochContext() {
  const context = (0, import_react5.useContext)(ClientContext);
  if (!context) {
    throw new Error(
      "Could not find RoochClientContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return context;
}

// src/hooks/client/useRoochClient.ts
function useRoochClient() {
  return useRoochContext().client;
}

// src/hooks/client/useRoochClientQuery.ts
var import_react_query = require("@tanstack/react-query");
function useRoochClientQuery(...args) {
  const [method, params, { queryKey = [], ...options } = {}] = args;
  const network = useCurrentNetwork();
  const roochClient = useRoochClient();
  return (0, import_react_query.useQuery)({
    ...options,
    queryKey: [network, method, params, ...queryKey],
    queryFn: async () => {
      return await roochClient[method](params);
    }
  });
}

// src/hooks/client/useSwitchNetwork.ts
var import_react_query2 = require("@tanstack/react-query");

// src/constants/roochMutationKeys.ts
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...roochMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var roochMutationKeys = {
  all: { baseScope: "rooch" },
  addNetwork: formMutationKeyFn("add-network"),
  switchNetwork: formMutationKeyFn("switch-network"),
  removeNetwork: formMutationKeyFn("remove-network"),
  removeSession: formMutationKeyFn("remove-session"),
  transferObject: formMutationKeyFn("transfer-object"),
  transferCoin: formMutationKeyFn("transfer-coin"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction")
};

// src/constants/walletMutationKeys.ts
function formMutationKeyFn2(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn2("connect-wallet"),
  autoConnectWallet: formMutationKeyFn2("auto-connect-wallet"),
  switchAccount: formMutationKeyFn2("switch-account"),
  createSessionKey: formMutationKeyFn2("create-session-key")
};

// src/hooks/client/useSwitchNetwork.ts
function useSwitchNetwork({
  mutationKey,
  ...mutationOptions
} = {}) {
  const switchNetwork = useRoochContext().selectNetwork;
  return (0, import_react_query2.useMutation)({
    mutationKey: roochMutationKeys.switchNetwork(mutationKey),
    mutationFn: async (args) => {
      switchNetwork(args);
    },
    ...mutationOptions
  });
}

// src/hooks/client/useTransferObject.ts
var import_react_query3 = require("@tanstack/react-query");
function useTransferObject({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  return (0, import_react_query3.useMutation)({
    mutationKey: roochMutationKeys.transferObject(mutationKey),
    mutationFn: async (args) => {
      const result = await client.transferObject(args);
      if (result.execution_info.status.type !== "executed") {
        Error("transfer failed" + result.execution_info.status.type);
      }
    },
    ...mutationOptions
  });
}

// src/hooks/client/useTransferCoin.ts
var import_react_query4 = require("@tanstack/react-query");

// src/hooks/useCurrentSession.ts
function useCurrentSession() {
  return useSessionStore((state) => state.currentSession);
}

// src/hooks/client/useTransferCoin.ts
function useTransferCoin({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const curSession = useCurrentSession();
  return (0, import_react_query4.useMutation)({
    mutationKey: roochMutationKeys.transferCoin(mutationKey),
    mutationFn: async (args) => {
      const signer = args.signer || curSession;
      if (signer === null) {
        throw Error("");
      }
      const result = await client.transfer({
        ...args,
        signer: args.signer || curSession
      });
      if (result.execution_info.status.type !== "executed") {
        Error("transfer failed" + result.execution_info.status.type);
      }
    },
    ...mutationOptions
  });
}

// src/hooks/client/networks-config.ts
function createNetworkConfig(networkConfig) {
  function useNetworkConfig() {
    const { config } = useRoochContext();
    if (!config) {
      throw new Error("No network config found");
    }
    return config;
  }
  function useNetworkVariables() {
    const { variables } = useNetworkConfig();
    return variables ?? {};
  }
  function useNetworkVariable(name) {
    const variables = useNetworkVariables();
    return variables[name];
  }
  return {
    networkConfig,
    useNetworkConfig,
    useNetworkVariables,
    useNetworkVariable
  };
}

// src/hooks/client/useSignAndExecuteTransaction.ts
var import_react_query5 = require("@tanstack/react-query");
function UseSignAndExecuteTransaction({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const session = useCurrentSession();
  return (0, import_react_query5.useMutation)({
    mutationKey: roochMutationKeys.signAndExecuteTransaction(mutationKey),
    mutationFn: async (args) => {
      if (!session) {
        throw Error("Create a session first");
      }
      const result = await client.signAndExecuteTransaction({
        transaction: args.transaction,
        signer: args.signer || session
      });
      if (result.execution_info.status.type !== "executed" && result.execution_info.status) {
        Error("transfer failed" + result.execution_info.status.type);
      }
      return result;
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useWalletStore.ts
var import_react6 = require("react");
var import_zustand4 = require("zustand");
function useWalletStore(selector) {
  const store = (0, import_react6.useContext)(WalletContext);
  if (!store) {
    throw new Error("Could not find WalletContext. Ensure that you have set up the WalletProvider.");
  }
  return (0, import_zustand4.useStore)(store, selector);
}

// src/hooks/wallet/useAddresses.ts
function useAddresses() {
  return useWalletStore((state) => state.addresses);
}

// src/hooks/wallet/useAutoConnectWallet.ts
var import_react_query6 = require("@tanstack/react-query");
var import_react7 = require("react");
function useAutoConnectWallet() {
  const { mutateAsync: connectWallet } = useConnectWallet();
  const autoConnectEnabled = useWalletStore((state) => state.autoConnectEnabled);
  const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);
  const lastConnectedAddress = useWalletStore((state) => state.lastConnectedAddress);
  const { isConnected } = useCurrentWallet();
  const wallets2 = useWallets();
  const [clientOnly, setClientOnly] = (0, import_react7.useState)(false);
  const currentAddress = useCurrentAddress();
  (0, import_react7.useLayoutEffect)(() => {
    setClientOnly(true);
  }, []);
  const { data, isError } = (0, import_react_query6.useQuery)({
    queryKey: [
      "@rooch/sdk-kit",
      "autoconnect",
      {
        isConnected,
        autoConnectEnabled,
        lastConnectedWalletName,
        lastConnectedAddress
      }
    ],
    queryFn: async () => {
      if (!autoConnectEnabled) {
        return "disabled";
      }
      if (!lastConnectedWalletName || !lastConnectedAddress || isConnected) {
        return "attempted";
      }
      let wallet = wallets2.find((wallet2) => wallet2.getName() === lastConnectedWalletName);
      if (wallet) {
        await connectWallet({ wallet });
        if (wallet.getChain() !== "bitcoin" && currentAddress?.toStr() !== lastConnectedAddress) {
          wallet.switchAccount(lastConnectedAddress);
        }
      }
      return "attempted";
    },
    enabled: autoConnectEnabled,
    persister: void 0,
    gcTime: 0,
    staleTime: 0,
    networkMode: "always",
    retry: (failureCount) => {
      if (wallets2.find((wallet) => wallet.getName() === lastConnectedWalletName) && failureCount < 3) {
        return true;
      }
      return false;
    },
    retryOnMount: false,
    refetchInterval: 1e3,
    refetchIntervalInBackground: false,
    refetchOnMount: false,
    refetchOnReconnect: false,
    refetchOnWindowFocus: false
  });
  if (!autoConnectEnabled) {
    return "disabled";
  }
  if (!clientOnly) {
    return "idle";
  }
  if (!lastConnectedWalletName) {
    return "attempted";
  }
  return isError ? "attempted" : data ?? "idle";
}

// src/hooks/wallet/useConnectWallet.ts
var import_react_query7 = require("@tanstack/react-query");

// src/hooks/useSessions.ts
function useSession() {
  return useSessionStore(
    (state) => state.sessions.sort((a, b) => b.getCreateTime() - a.getCreateTime())
  );
}

// src/hooks/wallet/useConnectWallet.ts
function useConnectWallet({
  mutationKey,
  ...mutationOptions
} = {}) {
  const sessions = useSession();
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const setWalletConnected = useWalletStore((state) => state.setWalletConnected);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  return (0, import_react_query7.useMutation)({
    mutationKey: walletMutationKeys.connectWallet(mutationKey),
    mutationFn: async ({ wallet }) => {
      try {
        setConnectionStatus("connecting");
        const connectAddress = await wallet.connect();
        const selectedAddress = connectAddress[0];
        setWalletConnected(wallet, connectAddress, selectedAddress);
        const cur = sessions.find(
          (item) => item.getRoochAddress().toStr() === selectedAddress?.genRoochAddress().toStr()
        );
        setCurrentSession(cur);
        return connectAddress;
      } catch (error) {
        setConnectionStatus("disconnected");
        throw error;
      }
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useCurrentAccount.ts
function useCurrentAddress() {
  return useWalletStore((state) => state.currentAddress);
}

// src/hooks/wallet/useCurrentWallet.ts
function useCurrentWallet() {
  const currentWallet = useWalletStore((state) => state.currentWallet);
  const connectionStatus = useWalletStore((state) => state.connectionStatus);
  switch (connectionStatus) {
    case "connecting":
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: false,
        isConnecting: true,
        isConnected: false
      };
    case "disconnected":
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: true,
        isConnecting: false,
        isConnected: false
      };
    case "connected": {
      return {
        status: connectionStatus,
        wallet: currentWallet,
        isDisconnected: false,
        isConnecting: false,
        isConnected: true
      };
    }
  }
}

// src/hooks/wallet/useWalletCreateSession.ts
var import_react_query8 = require("@tanstack/react-query");

// src/error/walletErrors.ts
var WalletNotConnectedError = class extends Error {
};

// src/hooks/wallet/useWalletCreateSession.ts
function useCreateSessionKey({
  mutationKey,
  ...mutationOptions
} = {}) {
  const client = useRoochClient();
  const currentWallet = useCurrentWallet();
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  return (0, import_react_query8.useMutation)({
    mutationKey: walletMutationKeys.createSessionKey(mutationKey),
    mutationFn: async (args) => {
      if (!currentWallet.isConnected) {
        throw new WalletNotConnectedError("No wallet is connected.");
      }
      const sessionAccount = await client.createSession({
        signer: currentWallet.wallet,
        sessionArgs: args
      });
      setCurrentSession(sessionAccount);
      return sessionAccount;
    },
    ...mutationOptions
  });
}

// src/hooks/wallet/useWallets.ts
function useWallets() {
  return useWalletStore((state) => state.wallets);
}

// src/hooks/wallet/useWalletChanged.ts
var import_react8 = require("react");

// src/wellet/wallets.ts
var wallets = void 0;
var registered = /* @__PURE__ */ new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  return wallets;
}
function register(...wallets2) {
  wallets2.forEach((wallet) => registered.add(wallet));
  listeners["register"]?.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    wallets2.forEach((wallet) => registered.delete(wallet));
    listeners["unregister"]?.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get() {
  return [...registered];
}
function on(event, listener) {
  listeners[event]?.push(listener) || (listeners[event] = [listener]);
  return function off() {
    listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}

// src/wellet/util.ts
function getRegisteredWallets(preferredWallets, walletFilter) {
  const walletsApi = getWallets();
  const wallets2 = walletsApi.get();
  const Wallets = wallets2.filter((wallet) => !walletFilter || walletFilter(wallet));
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => Wallets.find((wallet) => wallet.getName() === name)),
    // Wallets in default order:
    ...Wallets.filter((wallet) => !preferredWallets.includes(wallet.getName()))
  ].filter((wallet) => wallet !== void 0);
}

// src/hooks/wallet/useWalletChanged.ts
function useWalletChanged(preferredWallets, walletFilter) {
  const updateWallets = useWalletStore((state) => state.updateWallets);
  (0, import_react8.useEffect)(() => {
    const api = getWallets();
    updateWallets(getRegisteredWallets(preferredWallets, walletFilter));
    const unsubscribeFromRegister = api.on("register", () => {
      updateWallets(getRegisteredWallets(preferredWallets, walletFilter));
    });
    return () => {
      unsubscribeFromRegister();
    };
  }, [preferredWallets, updateWallets, walletFilter]);
}

// src/hooks/useRemoveSession.ts
var import_react_query9 = require("@tanstack/react-query");
function useRemoveSession({
  mutationKey,
  ...mutationOptions
} = {}) {
  const sessionsKeys = useSession();
  const removeSession = useSessionStore((state) => state.removeSession);
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const currentSession = useCurrentSession();
  const client = useRoochClient();
  const curSessionKey = useCurrentSession();
  return (0, import_react_query9.useMutation)({
    mutationKey: roochMutationKeys.removeSession(mutationKey),
    mutationFn: async (args) => {
      try {
        if (!curSessionKey) {
          return;
        }
        const result = await client.removeSession({
          authKey: args.authKey,
          signer: curSessionKey
        });
        if (result) {
          let cacheSession = sessionsKeys.find(
            (item) => item.getAuthKey() === args.authKey
          );
          if (cacheSession) {
            removeSession(cacheSession);
            if (cacheSession.getAuthKey() === currentSession?.getAuthKey()) {
              setCurrentSession(void 0);
            }
          }
        }
      } catch (e) {
        throw e;
      }
    },
    ...mutationOptions
  });
}

// src/provider/walletProvider.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var DEFAULT_STORAGE_KEY = "rooch-sdk-kit:wallet-connect-info";
var WalletContext = (0, import_react9.createContext)(null);
function WalletProvider({
  preferredWallets = ["unisat", "okx"],
  chain = "bitcoin",
  storage,
  storageKey = DEFAULT_STORAGE_KEY,
  autoConnect = false,
  children
}) {
  const network = useCurrentNetwork();
  const storeRef = (0, import_react9.useRef)(
    createWalletStore({
      chain,
      wallets: getRegisteredWallets(preferredWallets, (w) => w.getChain() === chain),
      currentWallet: void 0,
      autoConnectEnabled: autoConnect,
      storage: storage || getDefaultStorage(1 /* Local */),
      storageKey: storageKey + network + chain?.toString()
    })
  );
  (0, import_react9.useEffect)(() => {
    const fetchWallet = async () => {
      const wallets2 = await checkWallets(chain);
      getWallets().register(...wallets2);
    };
    fetchWallet();
  }, [chain]);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(WalletContext.Provider, { value: storeRef.current, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(WalletConnectionManager, { preferredWallets, chain, children }) });
}
function WalletConnectionManager({ children, preferredWallets }) {
  useAutoConnectWallet();
  useWalletChanged(preferredWallets);
  const connectionStatus = useWalletStore((store) => store.connectionStatus);
  const currentWallet = useWalletStore((store) => store.currentWallet);
  const setWalletDisconnected = useWalletStore((store) => store.setWalletDisconnected);
  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);
  const setAddressSwitched = useWalletStore((store) => store.setAddressSwitched);
  const currentAddress = useWalletStore((state) => state.currentAddress);
  const sessions = useSession();
  const curSession = useCurrentSession();
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const accountsChangedHandler = (0, import_react9.useCallback)(
    async (address) => {
      if (address.length === 0) {
        setWalletDisconnected();
      } else {
        setConnectionStatus("connecting");
        const selectedAddress = address[0];
        if (selectedAddress !== currentAddress?.toStr()) {
          setAddressSwitched(new import_rooch_sdk9.BitcoinAddress(selectedAddress));
          setCurrentSession(void 0);
          const cur = sessions.find(
            (item) => item.getRoochAddress().toStr() === currentAddress?.genRoochAddress().toStr()
          );
          if (cur && cur.getAuthKey() !== curSession?.getAuthKey()) {
            setCurrentSession(cur);
          }
        }
      }
    },
    [
      sessions,
      curSession,
      currentAddress,
      setAddressSwitched,
      setConnectionStatus,
      setCurrentSession,
      setWalletDisconnected
    ]
  );
  (0, import_react9.useEffect)(() => {
    if (connectionStatus === "connected") {
      currentWallet?.onAccountsChanged(accountsChangedHandler);
    }
    return () => {
      if (connectionStatus === "connected") {
        currentWallet?.removeAccountsChanged(accountsChangedHandler);
      }
    };
  }, [accountsChangedHandler, connectionStatus, currentWallet]);
  return children;
}
//# sourceMappingURL=index.js.map
