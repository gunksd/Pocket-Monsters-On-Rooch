"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/provider/roochProvider.tsx
var roochProvider_exports = {};
__export(roochProvider_exports, {
  RoochContext: () => RoochContext,
  RoochProvider: () => RoochProvider
});
module.exports = __toCommonJS(roochProvider_exports);
var import_react9 = require("react");

// src/provider/clientProvider.tsx
var import_react7 = require("react");
var import_react8 = require("react");
var import_rooch_sdk8 = require("@roochnetwork/rooch-sdk");

// src/hooks/useSessionsStore.ts
var import_react6 = require("react");
var import_zustand3 = require("zustand");

// src/provider/walletProvider.tsx
var import_react5 = require("react");
var import_rooch_sdk6 = require("@roochnetwork/rooch-sdk");

// src/provider/walletStore.ts
var import_zustand = require("zustand");
var import_middleware = require("zustand/middleware");

// src/hooks/client/useRoochContext.ts
var import_react = require("react");

// src/hooks/client/useRoochClientQuery.ts
var import_react_query = require("@tanstack/react-query");

// src/hooks/client/useSwitchNetwork.ts
var import_react_query2 = require("@tanstack/react-query");

// src/constants/roochMutationKeys.ts
function formMutationKeyFn(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...roochMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var roochMutationKeys = {
  all: { baseScope: "rooch" },
  addNetwork: formMutationKeyFn("add-network"),
  switchNetwork: formMutationKeyFn("switch-network"),
  removeNetwork: formMutationKeyFn("remove-network"),
  removeSession: formMutationKeyFn("remove-session"),
  transferObject: formMutationKeyFn("transfer-object"),
  transferCoin: formMutationKeyFn("transfer-coin"),
  signAndExecuteTransaction: formMutationKeyFn("sign-and-execute-transaction")
};

// src/constants/walletMutationKeys.ts
function formMutationKeyFn2(baseEntity) {
  return function mutationKeyFn(additionalKeys = []) {
    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];
  };
}
var walletMutationKeys = {
  all: { baseScope: "wallet" },
  connectWallet: formMutationKeyFn2("connect-wallet"),
  autoConnectWallet: formMutationKeyFn2("auto-connect-wallet"),
  switchAccount: formMutationKeyFn2("switch-account"),
  createSessionKey: formMutationKeyFn2("create-session-key")
};

// src/hooks/client/useTransferObject.ts
var import_react_query3 = require("@tanstack/react-query");

// src/hooks/client/useTransferCoin.ts
var import_react_query4 = require("@tanstack/react-query");

// src/hooks/client/useSignAndExecuteTransaction.ts
var import_react_query5 = require("@tanstack/react-query");

// src/hooks/wallet/useWalletStore.ts
var import_react2 = require("react");
var import_zustand2 = require("zustand");

// src/hooks/wallet/useAutoConnectWallet.ts
var import_react_query6 = require("@tanstack/react-query");
var import_react3 = require("react");

// src/hooks/wallet/useConnectWallet.ts
var import_react_query7 = require("@tanstack/react-query");

// src/hooks/wallet/useWalletCreateSession.ts
var import_react_query8 = require("@tanstack/react-query");

// src/hooks/wallet/useWalletChanged.ts
var import_react4 = require("react");

// src/hooks/useRemoveSession.ts
var import_react_query9 = require("@tanstack/react-query");

// src/utils/stateStorage.ts
function createInMemoryStore() {
  const store = /* @__PURE__ */ new Map();
  return {
    getItem(key) {
      return store.get(key);
    },
    setItem(key, value) {
      store.set(key, value);
    },
    removeItem(key) {
      store.delete(key);
    }
  };
}
function getDefaultStorage(type) {
  let storage;
  switch (type) {
    case 0 /* Session */:
      storage = typeof window !== "undefined" && window.sessionStorage ? sessionStorage : void 0;
      break;
    case 1 /* Local */:
      storage = typeof window !== "undefined" && window.localStorage ? localStorage : void 0;
  }
  if (!storage) {
    storage = createInMemoryStore();
  }
  return storage;
}

// src/wellet/wallet.ts
var import_rooch_sdk = require("@roochnetwork/rooch-sdk");

// src/wellet/bitcoin.ts
var import_rooch_sdk2 = require("@roochnetwork/rooch-sdk");

// src/wellet/unisat.ts
var import_rooch_sdk3 = require("@roochnetwork/rooch-sdk");

// src/wellet/okx.ts
var import_rooch_sdk4 = require("@roochnetwork/rooch-sdk");

// src/wellet/onekey.ts
var import_rooch_sdk5 = require("@roochnetwork/rooch-sdk");

// src/provider/walletProvider.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var WalletContext = (0, import_react5.createContext)(null);

// src/hooks/useSessionsStore.ts
function useSessionStore(selector) {
  const store = (0, import_react6.useContext)(RoochContext);
  if (!store) {
    throw new Error(
      "Could not find RoochSessionContext. Ensure that you have set up the RoochClientProvider."
    );
  }
  return (0, import_zustand3.useStore)(store, selector);
}

// src/http/httpTransport.ts
var import_rooch_sdk7 = require("@roochnetwork/rooch-sdk");
var HTTPTransport = class extends import_rooch_sdk7.RoochHTTPTransport {
  constructor(options, sessionExpiredCallback) {
    super(options);
    this.sessionExpiredCallback = sessionExpiredCallback;
  }
  async request(input) {
    let result;
    try {
      result = await super.request(input);
      return result;
    } catch (e) {
      if ("code" in e && (e.code === import_rooch_sdk7.ErrorValidateInvalidAccountAuthKey || e.code === import_rooch_sdk7.ErrorValidateSessionIsExpired)) {
        this.sessionExpiredCallback();
      }
      throw e;
    }
  }
};

// src/provider/clientProvider.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var ClientContext = (0, import_react8.createContext)(null);
var DEFAULT_NETWORKS = {
  localnet: { url: (0, import_rooch_sdk8.getRoochNodeUrl)("localnet") }
};
var DEFAULT_CREATE_CLIENT = function createClient(_name, config, setCurrentSession) {
  if ((0, import_rooch_sdk8.isRoochClient)(config)) {
    return config;
  }
  config.transport = new HTTPTransport(
    {
      url: config.url.toString()
    },
    setCurrentSession
  );
  return new import_rooch_sdk8.RoochClient(config);
};
function RoochClientProvider(props) {
  const { onNetworkChange, network, children } = props;
  const setCurrentSession = useSessionStore((state) => state.setCurrentSession);
  const networks = props.networks ?? DEFAULT_NETWORKS;
  const [selectedNetwork, setSelectedNetwork] = (0, import_react8.useState)(
    props.network ?? props.defaultNetwork ?? Object.keys(networks)[0]
  );
  const currentNetwork = props.network ?? selectedNetwork;
  const clearSession = (0, import_react7.useCallback)(() => {
    try {
      setCurrentSession(void 0);
    } catch (e) {
      console.log(e);
    }
  }, [setCurrentSession]);
  const client = (0, import_react8.useMemo)(() => {
    return DEFAULT_CREATE_CLIENT(currentNetwork, networks[currentNetwork], () => {
      clearSession();
    });
  }, [currentNetwork, networks, clearSession]);
  const ctx = (0, import_react8.useMemo)(() => {
    return {
      client,
      network: currentNetwork,
      networks,
      config: networks[currentNetwork] instanceof import_rooch_sdk8.RoochClient ? null : networks[currentNetwork],
      selectNetwork: (newNetwork) => {
        if (currentNetwork === newNetwork) {
          return;
        }
        if (!network && newNetwork !== selectedNetwork) {
          setSelectedNetwork(newNetwork);
        }
        onNetworkChange?.(newNetwork);
      }
    };
  }, [client, currentNetwork, networks, network, selectedNetwork, onNetworkChange]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ClientContext.Provider, { value: ctx, children });
}

// src/provider/sessionStore.ts
var import_zustand4 = require("zustand");
var import_middleware2 = require("zustand/middleware");
var import_rooch_sdk9 = require("@roochnetwork/rooch-sdk");
function createSessionStore({ storage, storageKey }) {
  return (0, import_zustand4.createStore)()(
    (0, import_middleware2.persist)(
      (set, get) => ({
        sessions: [],
        currentSession: null,
        addSession(session) {
          const cache = get().sessions;
          cache.push(session);
          set(() => ({
            sessions: cache
          }));
        },
        setCurrentSession(session) {
          if (!session) {
            set(() => ({
              currentSession: null
            }));
          } else {
            const cache = get().sessions;
            if (!cache.find((item) => item.getAuthKey() === session.getAuthKey())) {
              cache.push(session);
            }
            set(() => ({
              currentSession: session,
              sessions: cache
            }));
          }
        },
        removeSession(session) {
          const cacheSessions = get().sessions;
          const cacheCurSession = get().currentSession;
          set(() => ({
            currentSession: cacheCurSession?.getAuthKey() === session.getAuthKey() ? null : cacheCurSession,
            sessions: cacheSessions.filter((c) => c.getAuthKey() !== session.getAuthKey())
          }));
        }
      }),
      {
        name: storageKey,
        storage: (0, import_middleware2.createJSONStorage)(() => storage, {
          reviver: (key, value) => {
            if (key === "sessions") {
              return value.map((session) => import_rooch_sdk9.Session.fromJson(session));
            }
            return value;
          }
        }),
        partialize: ({ sessions }) => ({
          sessions
        })
      }
    )
  );
}

// src/provider/roochProvider.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var DEFAULT_SESSION_STORAGE_KEY = function(_) {
  return "rooch-sdk-kit:rooch-session-info";
};
var RoochContext = (0, import_react9.createContext)(null);
function RoochProvider(props) {
  const { children, networks, defaultNetwork } = props;
  const storeRef = (0, import_react9.useRef)(
    createSessionStore({
      storage: getDefaultStorage(1 /* Local */),
      storageKey: DEFAULT_SESSION_STORAGE_KEY()
    })
  );
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(RoochContext.Provider, { value: storeRef.current, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(RoochClientProvider, { networks, defaultNetwork, children }) });
}
//# sourceMappingURL=roochProvider.js.map
