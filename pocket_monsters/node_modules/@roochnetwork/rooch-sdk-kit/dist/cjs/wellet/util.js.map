{
  "version": 3,
  "sources": ["../../../src/wellet/util.ts", "../../../src/wellet/wallets.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Wallet } from './wallet.js'\nimport { getWallets } from './wallets.js'\n\nexport function getRegisteredWallets(\n  preferredWallets: string[],\n  walletFilter?: (wallet: Wallet) => boolean,\n): Wallet[] {\n  const walletsApi = getWallets()\n  const wallets = walletsApi.get()\n\n  const Wallets = wallets.filter((wallet) => !walletFilter || walletFilter(wallet))\n\n  return [\n    // Preferred wallets, in order:\n    ...preferredWallets.map((name) => Wallets.find((wallet) => wallet.getName() === name)),\n    // Wallets in default order:\n    ...Wallets.filter((wallet) => !preferredWallets.includes(wallet.getName())),\n  ].filter((wallet): wallet is Wallet => wallet !== undefined)\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Wallet } from './wallet.js'\n\nlet wallets: Wallets | undefined = undefined\nconst registered = new Set<Wallet>()\nconst listeners: { [E in WalletsEventNames]?: WalletsEventsListeners[E][] } = {}\n\nexport function getWallets(): Wallets {\n  if (wallets) return wallets\n  wallets = Object.freeze({ register, get, on })\n\n  return wallets\n}\n\nexport interface Wallets {\n  /**\n   * Get all Wallets that have been registered.\n   *\n   * @return Registered Wallets.\n   */\n  get(): readonly Wallet[]\n\n  /**\n   * Add an event listener and subscribe to events for Wallets that are\n   * {@link WalletsEventsListeners.register | registered} and\n   * {@link WalletsEventsListeners.unregister | unregistered}.\n   *\n   * @param event    Event type to listen for. {@link WalletsEventsListeners.register | `register`} and\n   * {@link WalletsEventsListeners.unregister | `unregister`} are the only event types.\n   * @param listener Function that will be called when an event of the type is emitted.\n   *\n   * @return\n   * `off` function which may be called to remove the event listener and unsubscribe from events.\n   *\n   * As with all event listeners, be careful to avoid memory leaks.\n   */\n  on<E extends WalletsEventNames>(event: E, listener: WalletsEventsListeners[E]): () => void\n\n  /**\n   * Register Wallets. This can be used to programmatically wrap non-standard wallets as Standard Wallets.\n   *\n   * Apps generally do not need to, and should not, call this.\n   *\n   * @param wallets Wallets to register.\n   *\n   * @return\n   * `unregister` function which may be called to programmatically unregister the registered Wallets.\n   *\n   * Apps generally do not need to, and should not, call this.\n   */\n  register(...wallets: Wallet[]): () => void\n}\n\nexport interface WalletsEventsListeners {\n  /**\n   * Emitted when Wallets are registered.\n   *\n   * @param wallets Wallets that were registered.\n   */\n  register(...wallets: Wallet[]): void\n\n  /**\n   * Emitted when Wallets are unregistered.\n   *\n   * @param wallets Wallets that were unregistered.\n   */\n  unregister(...wallets: Wallet[]): void\n}\n\n/**\n * Names of {@link WalletsEventsListeners} that can be listened for.\n *\n * @group App\n */\nexport type WalletsEventNames = keyof WalletsEventsListeners\n\nexport function register(...wallets: Wallet[]) {\n  wallets.forEach((wallet) => registered.add(wallet))\n  listeners['register']?.forEach((listener) => guard(() => listener(...wallets)))\n\n  return function unregister(): void {\n    wallets.forEach((wallet) => registered.delete(wallet))\n    listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)))\n  }\n}\n\nfunction get(): readonly Wallet[] {\n  return [...registered]\n}\n\nfunction on<E extends WalletsEventNames>(\n  event: E,\n  listener: WalletsEventsListeners[E],\n): () => void {\n  listeners[event]?.push(listener) || (listeners[event] = [listener])\n  // Return a function that removes the event listener.\n  return function off(): void {\n    listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener)\n  }\n}\n\nfunction guard(callback: () => void) {\n  try {\n    callback()\n  } catch (error) {\n    console.error(error)\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACKA,IAAI,UAA+B;AACnC,IAAM,aAAa,oBAAI,IAAY;AACnC,IAAM,YAAwE,CAAC;AAExE,SAAS,aAAsB;AACpC,MAAI;AAAS,WAAO;AACpB,YAAU,OAAO,OAAO,EAAE,UAAU,KAAK,GAAG,CAAC;AAE7C,SAAO;AACT;AAgEO,SAAS,YAAYA,UAAmB;AAC7C,EAAAA,SAAQ,QAAQ,CAAC,WAAW,WAAW,IAAI,MAAM,CAAC;AAClD,YAAU,UAAU,GAAG,QAAQ,CAAC,aAAa,MAAM,MAAM,SAAS,GAAGA,QAAO,CAAC,CAAC;AAE9E,SAAO,SAAS,aAAmB;AACjC,IAAAA,SAAQ,QAAQ,CAAC,WAAW,WAAW,OAAO,MAAM,CAAC;AACrD,cAAU,YAAY,GAAG,QAAQ,CAAC,aAAa,MAAM,MAAM,SAAS,GAAGA,QAAO,CAAC,CAAC;AAAA,EAClF;AACF;AAEA,SAAS,MAAyB;AAChC,SAAO,CAAC,GAAG,UAAU;AACvB;AAEA,SAAS,GACP,OACA,UACY;AACZ,YAAU,KAAK,GAAG,KAAK,QAAQ,MAAM,UAAU,KAAK,IAAI,CAAC,QAAQ;AAEjE,SAAO,SAAS,MAAY;AAC1B,cAAU,KAAK,IAAI,UAAU,KAAK,GAAG,OAAO,CAAC,qBAAqB,aAAa,gBAAgB;AAAA,EACjG;AACF;AAEA,SAAS,MAAM,UAAsB;AACnC,MAAI;AACF,aAAS;AAAA,EACX,SAAS,OAAP;AACA,YAAQ,MAAM,KAAK;AAAA,EACrB;AACF;;;ADvGO,SAAS,qBACd,kBACA,cACU;AACV,QAAM,aAAa,WAAW;AAC9B,QAAMC,WAAU,WAAW,IAAI;AAE/B,QAAM,UAAUA,SAAQ,OAAO,CAAC,WAAW,CAAC,gBAAgB,aAAa,MAAM,CAAC;AAEhF,SAAO;AAAA;AAAA,IAEL,GAAG,iBAAiB,IAAI,CAAC,SAAS,QAAQ,KAAK,CAAC,WAAW,OAAO,QAAQ,MAAM,IAAI,CAAC;AAAA;AAAA,IAErF,GAAG,QAAQ,OAAO,CAAC,WAAW,CAAC,iBAAiB,SAAS,OAAO,QAAQ,CAAC,CAAC;AAAA,EAC5E,EAAE,OAAO,CAAC,WAA6B,WAAW,MAAS;AAC7D;",
  "names": ["wallets", "wallets"]
}
