{
  "version": 3,
  "sources": ["../../../../src/hooks/wallet/useWalletStore.ts", "../../../../src/provider/roochProvider.tsx", "../../../../src/provider/clientProvider.tsx", "../../../../src/hooks/useSessionsStore.ts", "../../../../src/http/httpTransport.ts", "../../../../src/provider/sessionStore.ts", "../../../../src/wellet/wallet.ts", "../../../../src/wellet/bitcoin.ts", "../../../../src/wellet/unisat.ts", "../../../../src/wellet/okx.ts", "../../../../src/wellet/onekey.ts", "../../../../src/provider/walletProvider.tsx", "../../../../src/provider/walletStore.ts", "../../../../src/hooks/client/useRoochContext.ts", "../../../../src/hooks/client/useRoochClientQuery.ts", "../../../../src/hooks/client/useSwitchNetwork.ts", "../../../../src/constants/roochMutationKeys.ts", "../../../../src/constants/walletMutationKeys.ts", "../../../../src/hooks/client/useTransferObject.ts", "../../../../src/hooks/client/useTransferCoin.ts", "../../../../src/hooks/client/useSignAndExecuteTransaction.ts", "../../../../src/hooks/useRemoveSession.ts", "../../../../src/hooks/wallet/useAutoConnectWallet.ts", "../../../../src/hooks/wallet/useConnectWallet.ts", "../../../../src/hooks/wallet/useWalletCreateSession.ts", "../../../../src/hooks/wallet/useWalletChanged.ts", "../../../../src/hooks/wallet/useCurrentAccount.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nimport { WalletContext } from '../../provider/index.js'\nimport type { WalletStoreState } from '../../provider/walletStore.js'\n\nexport function useWalletStore<T>(selector: (state: WalletStoreState) => T): T {\n  const store = useContext(WalletContext)\n  if (!store) {\n    throw new Error('Could not find WalletContext. Ensure that you have set up the WalletProvider.')\n  }\n  return useStore(store, selector)\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ReactNode } from 'react'\nimport { createContext, useRef } from 'react'\n\nimport { NetworkConfigs, RoochClientProvider } from './clientProvider.js'\nimport { createSessionStore, SessionStore } from './sessionStore.js'\nimport { getDefaultStorage, StorageType } from '../utils/index.js'\n\nconst DEFAULT_SESSION_STORAGE_KEY = function (_?: string) {\n  return 'rooch-sdk-kit:rooch-session-info'\n}\n\nexport const RoochContext = createContext<SessionStore | null>(null)\n\nexport type RoochProviderProps<T extends NetworkConfigs> = {\n  networks?: NetworkConfigs\n  onNetworkChange?: (network: keyof T & string) => void\n\n  children: ReactNode\n} & (\n  | {\n      defaultNetwork?: keyof T & string\n      network?: never\n    }\n  | {\n      defaultNetwork?: never\n      network?: keyof T & string\n    }\n)\n\nexport function RoochProvider<T extends NetworkConfigs>(props: RoochProviderProps<T>) {\n  // ** Props **\n  const { children, networks, defaultNetwork } = props\n\n  const storeRef = useRef(\n    createSessionStore({\n      storage: getDefaultStorage(StorageType.Local),\n      storageKey: DEFAULT_SESSION_STORAGE_KEY(),\n    }),\n  )\n  return (\n    <RoochContext.Provider value={storeRef.current}>\n      <RoochClientProvider networks={networks} defaultNetwork={defaultNetwork}>\n        {children}\n      </RoochClientProvider>\n    </RoochContext.Provider>\n  )\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ReactNode, useCallback } from 'react'\n\nimport { createContext, useMemo, useState } from 'react'\n\nimport {\n  getRoochNodeUrl,\n  isRoochClient,\n  RoochClient,\n  RoochClientOptions,\n} from '@roochnetwork/rooch-sdk'\n\nimport { NetworkConfig } from '../hooks/index.js'\nimport { useSessionStore } from '../hooks/useSessionsStore.js'\nimport { HTTPTransport } from '../http/httpTransport.js'\n\nexport type NetworkConfigs<T extends NetworkConfig | RoochClient = NetworkConfig | RoochClient> =\n  Record<string, T>\n\nexport interface ClientProviderContext {\n  client: RoochClient\n  networks: NetworkConfigs\n  network: string\n  config: NetworkConfig | null\n  selectNetwork: (network: string) => void\n}\n\nexport const ClientContext = createContext<ClientProviderContext | null>(null)\n\nexport type RoochClientProviderProps<T extends NetworkConfigs> = {\n  networks?: NetworkConfigs\n  onNetworkChange?: (network: keyof T & string) => void\n  children: ReactNode\n} & (\n  | {\n      defaultNetwork?: keyof T & string\n      network?: never\n    }\n  | {\n      defaultNetwork?: never\n      network?: keyof T & string\n    }\n)\n\nconst DEFAULT_NETWORKS = {\n  localnet: { url: getRoochNodeUrl('localnet') },\n}\n\nconst DEFAULT_CREATE_CLIENT = function createClient(\n  _name: string,\n  config: NetworkConfig | RoochClient,\n  setCurrentSession: any,\n) {\n  if (isRoochClient(config)) {\n    return config\n  }\n\n  config.transport = new HTTPTransport(\n    {\n      url: config.url!.toString(),\n    },\n    setCurrentSession,\n  )\n\n  return new RoochClient(config)\n}\n\nexport function RoochClientProvider<T extends NetworkConfigs>(props: RoochClientProviderProps<T>) {\n  const { onNetworkChange, network, children } = props\n  const setCurrentSession = useSessionStore((state) => state.setCurrentSession)\n  const networks = (props.networks ?? DEFAULT_NETWORKS) as T\n  const [selectedNetwork, setSelectedNetwork] = useState<keyof T & string>(\n    props.network ?? props.defaultNetwork ?? (Object.keys(networks)[0] as keyof T & string),\n  )\n  const currentNetwork = props.network ?? selectedNetwork\n\n  const clearSession = useCallback(() => {\n    try {\n      setCurrentSession(undefined)\n    } catch (e) {\n      console.log(e)\n    }\n  }, [setCurrentSession])\n\n  const client = useMemo(() => {\n    return DEFAULT_CREATE_CLIENT(currentNetwork, networks[currentNetwork], () => {\n      clearSession()\n    })\n  }, [currentNetwork, networks, clearSession])\n\n  const ctx = useMemo((): ClientProviderContext => {\n    return {\n      client,\n      network: currentNetwork,\n      networks,\n      config:\n        networks[currentNetwork] instanceof RoochClient\n          ? null\n          : (networks[currentNetwork] as RoochClientOptions),\n      selectNetwork: (newNetwork) => {\n        if (currentNetwork === newNetwork) {\n          return\n        }\n\n        if (!network && newNetwork !== selectedNetwork) {\n          setSelectedNetwork(newNetwork)\n        }\n\n        onNetworkChange?.(newNetwork)\n      },\n    }\n  }, [client, currentNetwork, networks, network, selectedNetwork, onNetworkChange])\n\n  return <ClientContext.Provider value={ctx}>{children}</ClientContext.Provider>\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nimport { SessionStoreState } from '../provider/sessionStore.js'\nimport { RoochContext } from '../provider/index.js'\n\nexport function useSessionStore<T>(selector: (state: SessionStoreState) => T): T {\n  const store = useContext(RoochContext)\n  if (!store) {\n    throw new Error(\n      'Could not find RoochSessionContext. Ensure that you have set up the RoochClientProvider.',\n    )\n  }\n  return useStore(store, selector)\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  RoochHTTPTransport,\n  RoochTransportRequestOptions,\n  RoochHTTPTransportOptions,\n  ErrorValidateInvalidAccountAuthKey,\n  ErrorValidateSessionIsExpired,\n} from '@roochnetwork/rooch-sdk'\n\ntype SessionExpiredCallbackType = () => void\n\nexport class HTTPTransport extends RoochHTTPTransport {\n  private readonly sessionExpiredCallback: SessionExpiredCallbackType\n\n  constructor(\n    options: RoochHTTPTransportOptions,\n    sessionExpiredCallback: SessionExpiredCallbackType,\n  ) {\n    super(options)\n    this.sessionExpiredCallback = sessionExpiredCallback\n  }\n\n  async request<T>(input: RoochTransportRequestOptions): Promise<T> {\n    let result: T\n    try {\n      result = await super.request(input)\n      return result\n    } catch (e: any) {\n      if (\n        'code' in e &&\n        (e.code === ErrorValidateInvalidAccountAuthKey || e.code === ErrorValidateSessionIsExpired)\n      ) {\n        this.sessionExpiredCallback()\n      }\n      throw e\n    }\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createStore } from 'zustand'\nimport { createJSONStorage, persist, StateStorage } from 'zustand/middleware'\nimport { Session } from '@roochnetwork/rooch-sdk'\n\nexport type SessionActions = {\n  addSession: (session: Session) => void\n  setCurrentSession: (session?: Session) => void\n  removeSession: (session: Session) => void\n}\n\nexport type SessionStoreState = {\n  sessions: Session[]\n  currentSession: Session | null\n} & SessionActions\n\nexport type SessionStore = ReturnType<typeof createSessionStore>\n\ntype ClientConfiguration = {\n  storage: StateStorage\n  storageKey: string\n}\n\nexport function createSessionStore({ storage, storageKey }: ClientConfiguration) {\n  return createStore<SessionStoreState>()(\n    persist(\n      (set, get) => ({\n        sessions: [],\n        currentSession: null,\n        addSession(session) {\n          const cache = get().sessions\n          cache.push(session)\n          set(() => ({\n            sessions: cache,\n          }))\n        },\n        setCurrentSession(session) {\n          if (!session) {\n            set(() => ({\n              currentSession: null,\n            }))\n          } else {\n            const cache = get().sessions\n            if (!cache.find((item) => item.getAuthKey() === session.getAuthKey())) {\n              cache.push(session)\n            }\n            set(() => ({\n              currentSession: session,\n              sessions: cache,\n            }))\n          }\n        },\n        removeSession(session) {\n          const cacheSessions = get().sessions\n          const cacheCurSession = get().currentSession\n          set(() => ({\n            currentSession:\n              cacheCurSession?.getAuthKey() === session.getAuthKey() ? null : cacheCurSession,\n            sessions: cacheSessions.filter((c) => c.getAuthKey() !== session.getAuthKey()),\n          }))\n        },\n      }),\n      {\n        name: storageKey,\n        storage: createJSONStorage(() => storage, {\n          reviver: (key, value) => {\n            if (key === 'sessions') {\n              return (value as any[]).map((session: any) => Session.fromJson(session))\n            }\n            return value\n          },\n        }),\n        partialize: ({ sessions }) => ({\n          sessions,\n        }),\n      },\n    ),\n  )\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ThirdPartyAddress, Bytes, Signer } from '@roochnetwork/rooch-sdk'\n\nimport { SupportChain } from '../feature/index.js'\n\nexport abstract class Wallet extends Signer {\n  protected address: ThirdPartyAddress[] | undefined\n  protected publicKey: string | undefined\n  protected currentAddress: ThirdPartyAddress | undefined\n\n  /**\n   * Connects the wallet.\n   * @returns A promise that resolves to an array of wallet accounts.\n   */\n  abstract connect(): Promise<ThirdPartyAddress[]>\n\n  abstract getName(): string\n  /**\n   * Signs a message.\n   * @param msg - The message to sign.\n   * @returns A promise that resolves to the signature string.\n   */\n  abstract sign(msg: Bytes): Promise<Bytes>\n\n  /**\n   * Switches the network.\n   */\n  abstract switchNetwork(network: string): void\n\n  /**\n   * Switches the account.\n   * Note: Wallets with Bitcoin chain are not currently supported.\n   */\n  abstract switchAccount(address: string): void\n\n  /**\n   * Retrieves the current network of the wallet.\n   * @returns The current network as a string.\n   */\n  abstract getNetwork(): string\n\n  /**\n   * Retrieves the supported networks of the wallet.\n   * @returns An array of supported network strings.\n   */\n  abstract getSupportNetworks(): string[]\n\n  /**\n   * Registers a callback function to be invoked when accounts are changed.\n   * @param callback - A function to be called when accounts are changed. It receives an array of account strings as its argument.\n   */\n  abstract onAccountsChanged(callback: (accounts: Array<string>) => void): void\n\n  /**\n   * Removes a previously registered callback function for account changes.\n   * @param callback - The callback function to be removed.\n   */\n  abstract removeAccountsChanged(callback: (accounts: Array<string>) => void): void\n\n  /**\n   * Registers a callback function to be invoked when the network is changed.\n   * @param callback - A function to be called when the network is changed. It receives the new network as its argument.\n   */\n  abstract onNetworkChanged(callback: (network: string) => void): void\n\n  /**\n   * Removes a previously registered callback function for network changes.\n   * @param callback - The callback function to be removed.\n   */\n  abstract removeNetworkChanged(callback: (network: string) => void): void\n\n  /**\n   * Retrieves the target of the wallet.\n   * @returns The target of the wallet.\n   */\n  abstract getTarget(): any\n\n  abstract getChain(): SupportChain\n\n  /**\n   * Normalizes the recovery ID.\n   * @param recoveryID - The recovery ID to be normalized.\n   * @returns The normalized recovery ID as a number.\n   */\n  protected abstract normalize_recovery_id(recoveryID: number): number\n\n  /**\n   * Checks if the wallet is installed.\n   * @returns A promise that resolves to true if the wallet is installed, otherwise false.\n   */\n  async checkInstalled(): Promise<boolean> {\n    for (let i = 1; i < 10 && !this.getTarget(); i += 1) {\n      await new Promise((resolve) => setTimeout(resolve, 100 * i))\n    }\n    return Promise.resolve(this.getTarget() !== undefined)\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  Address,\n  Authenticator,\n  BitcoinAddress,\n  BitcoinSignMessage,\n  PublicKey,\n  RoochAddress,\n  Secp256k1PublicKey,\n  SignatureScheme,\n  fromHEX,\n  Transaction,\n} from '@roochnetwork/rooch-sdk'\n\nimport { SupportChain } from '../feature/index.js'\nimport { Wallet } from '../wellet/index.js'\n\nexport abstract class BitcoinWallet extends Wallet {\n  async signTransaction(input: Transaction): Promise<Authenticator> {\n    const message = new BitcoinSignMessage(input.hashData(), input.getInfo() || '')\n    return Authenticator.bitcoin(message, this, 'raw')\n  }\n\n  getPublicKey(): PublicKey<Address> {\n    if (!this.publicKey) {\n      throw Error('Please connect your wallet first')\n    }\n\n    return new Secp256k1PublicKey(fromHEX(this.publicKey))\n  }\n\n  getRoochAddress(): RoochAddress {\n    if (!this.currentAddress) {\n      throw Error('Please connect your wallet first')\n    }\n    return (this.currentAddress as BitcoinAddress).genRoochAddress()\n  }\n\n  getBitcoinAddress(): BitcoinAddress {\n    if (!this.currentAddress) {\n      throw Error('Please connect your wallet first')\n    }\n    return this.currentAddress as BitcoinAddress\n  }\n\n  getKeyScheme(): SignatureScheme {\n    return 'Secp256k1'\n  }\n\n  normalize_recovery_id(v: number) {\n    let normalizeV = v - 27 - 4\n\n    if (normalizeV < 0) {\n      normalizeV = normalizeV + 4\n    }\n\n    return normalizeV\n  }\n\n  switchAccount(): void {\n    throw new Error('Method not implemented.')\n  }\n\n  getChain(): SupportChain {\n    return 'bitcoin'\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BitcoinAddress, Bytes, ThirdPartyAddress, str, bytes } from '@roochnetwork/rooch-sdk'\n\nimport { BitcoinWallet } from '../wellet/index.js'\n\nconst UNISAT_SUPPORT_NETWORKS = ['livenet', 'testnet']\n\nexport class UniSatWallet extends BitcoinWallet {\n  getName(): string {\n    return 'unisat'\n  }\n\n  getTarget(): any {\n    return (window as any).unisat\n  }\n\n  async connect(): Promise<ThirdPartyAddress[]> {\n    let addresses: string[] = await this.getTarget().getAccounts()\n\n    if (!addresses || addresses.length === 0) {\n      await this.getTarget().requestAccounts()\n      return this.connect()\n    }\n\n    let publicKey = await this.getTarget().getPublicKey()\n\n    this.address = addresses.map((item) => new BitcoinAddress(item))\n    this.currentAddress = this.address[0]\n    this.publicKey = publicKey\n\n    return this.address\n  }\n\n  switchNetwork(network: string): void {\n    this.getTarget().switchNetwork(network)\n  }\n  getNetwork(): string {\n    return this.getTarget().getNetwork()\n  }\n\n  getSupportNetworks(): string[] {\n    return UNISAT_SUPPORT_NETWORKS\n  }\n\n  onAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().on('accountsChanged', callback)\n  }\n\n  removeAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().removeListener('accountsChanged', callback)\n  }\n\n  onNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().on('networkChanged', callback)\n  }\n\n  removeNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().removeListener('networkChanged', callback)\n  }\n\n  async sign(msg: Bytes): Promise<Bytes> {\n    const msgStr = str('utf8', msg)\n    const sign = await this.getTarget().signMessage(msgStr)\n    return bytes('base64', sign).subarray(1) // remove recover id\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BitcoinAddress, Bytes, ThirdPartyAddress, str, bytes } from '@roochnetwork/rooch-sdk'\nimport { BitcoinWallet } from '../wellet/index.js'\n\nexport class OkxWallet extends BitcoinWallet {\n  getName(): string {\n    return 'okx'\n  }\n\n  async sign(msg: Bytes): Promise<Bytes> {\n    const msgStr = str('utf8', msg)\n    const sign = await this.getTarget().signMessage(msgStr, {\n      from: this.currentAddress?.toStr(),\n    })\n    return bytes('base64', sign).subarray(1)\n  }\n\n  getTarget(): any {\n    return (window as any).okxwallet?.bitcoin\n  }\n\n  async connect(): Promise<ThirdPartyAddress[]> {\n    const obj = await this.getTarget().connect()\n    this.currentAddress = new BitcoinAddress(obj.address)\n    this.publicKey = obj.compressedPublicKey !== '' ? obj.compressedPublicKey : obj.publicKey\n    this.address = [this.currentAddress]\n\n    return this.address\n  }\n\n  switchNetwork(): void {\n    this.getTarget().switchNetwork()\n  }\n\n  getNetwork(): string {\n    return this.getTarget().getNetwork()\n  }\n\n  getSupportNetworks(): string[] {\n    return ['livenet']\n  }\n\n  onAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().on('accountsChanged', callback)\n  }\n\n  removeAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().removeListener('accountsChanged', callback)\n  }\n\n  onNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().on('networkChanged', callback)\n  }\n\n  removeNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().removeListener('networkChanged', callback)\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BitcoinAddress, Bytes, ThirdPartyAddress, str, bytes } from '@roochnetwork/rooch-sdk'\nimport { BitcoinWallet } from '../wellet/index.js'\n\nexport class OnekeyWallet extends BitcoinWallet {\n  getName(): string {\n    return 'onekey'\n  }\n\n  async sign(msg: Bytes): Promise<Bytes> {\n    const msgStr = str('utf8', msg)\n    const sign = await this.getTarget().signMessage(msgStr)\n    return bytes('base64', sign).subarray(1)\n  }\n\n  getTarget(): any {\n    return (window as any).$onekey?.btc\n  }\n\n  async connect(): Promise<ThirdPartyAddress[]> {\n    let addresses: string[] = await this.getTarget().getAccounts()\n\n    if (!addresses || addresses.length === 0) {\n      await this.getTarget().requestAccounts()\n      return this.connect()\n    }\n\n    let publicKey = await this.getTarget().getPublicKey()\n\n    this.address = addresses.map((item) => new BitcoinAddress(item))\n    this.currentAddress = this.address[0]\n    this.publicKey = publicKey\n\n    return this.address\n  }\n\n  switchNetwork(): void {\n    this.getTarget().switchNetwork()\n  }\n\n  getNetwork(): string {\n    return this.getTarget().getNetwork()\n  }\n\n  getSupportNetworks(): string[] {\n    return ['livenet']\n  }\n\n  onAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().on('accountsChanged', callback)\n  }\n\n  removeAccountsChanged(callback: (account: string[]) => void): void {\n    this.getTarget().removeListener('accountsChanged', callback)\n  }\n\n  onNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().on('networkChanged', callback)\n  }\n\n  removeNetworkChanged(callback: (network: string) => void): void {\n    this.getTarget().removeListener('networkChanged', callback)\n  }\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ReactNode, useCallback, createContext, useEffect, useRef } from 'react'\nimport type { StateStorage } from 'zustand/middleware'\nimport { BitcoinAddress, Session } from '@roochnetwork/rooch-sdk'\n\nimport { createWalletStore, WalletStore } from './walletStore.js'\nimport {\n  useAutoConnectWallet,\n  useCurrentSession,\n  useSession,\n  useWalletStore,\n  useCurrentNetwork,\n} from '../hooks/index.js'\nimport { useSessionStore } from '../hooks/useSessionsStore.js'\nimport { getDefaultStorage, StorageType, checkWallets } from '../utils/index.js'\nimport { SupportChain, SupportWallet } from '../feature/index.js'\nimport { getRegisteredWallets } from '../wellet/util.js'\nimport { getWallets } from '../wellet/wallets.js'\nimport { useWalletChanged } from '../hooks/index.js'\n\ntype WalletProviderProps = {\n  preferredWallets?: SupportWallet[]\n\n  chain?: SupportChain\n\n  /** Enables automatically reconnecting to the most recently used wallet account upon mounting. */\n  autoConnect?: boolean\n\n  /** Configures how the most recently connected to wallet account is stored. Defaults to using localStorage. */\n  storage?: StateStorage\n\n  /** The key to use to store the most recently connected wallet account. */\n  storageKey?: string\n\n  children: ReactNode\n}\n\nconst DEFAULT_STORAGE_KEY = 'rooch-sdk-kit:wallet-connect-info'\n\nexport const WalletContext = createContext<WalletStore | null>(null)\n\nexport function WalletProvider({\n  preferredWallets = ['unisat', 'okx'],\n  chain = 'bitcoin',\n  storage,\n  storageKey = DEFAULT_STORAGE_KEY,\n  autoConnect = false,\n  children,\n}: WalletProviderProps) {\n  const network = useCurrentNetwork()\n\n  const storeRef = useRef(\n    createWalletStore({\n      chain,\n      wallets: getRegisteredWallets(preferredWallets, (w) => w.getChain() === chain),\n      currentWallet: undefined,\n      autoConnectEnabled: autoConnect,\n      storage: storage || getDefaultStorage(StorageType.Local),\n      storageKey: storageKey + network + chain?.toString(),\n    }),\n  )\n\n  useEffect(() => {\n    const fetchWallet = async () => {\n      const wallets = await checkWallets(chain)\n      getWallets().register(...wallets)\n    }\n\n    fetchWallet()\n  }, [chain])\n\n  return (\n    <WalletContext.Provider value={storeRef.current}>\n      <WalletConnectionManager preferredWallets={preferredWallets} chain={chain}>\n        {children}\n      </WalletConnectionManager>\n    </WalletContext.Provider>\n  )\n}\n\ntype WalletConnectionManagerProps = Required<\n  Pick<WalletProviderProps, 'children' | 'preferredWallets' | 'chain'>\n>\n\nfunction WalletConnectionManager({ children, preferredWallets }: WalletConnectionManagerProps) {\n  useAutoConnectWallet()\n  useWalletChanged(preferredWallets)\n\n  const connectionStatus = useWalletStore((store) => store.connectionStatus)\n  const currentWallet = useWalletStore((store) => store.currentWallet)\n  const setWalletDisconnected = useWalletStore((store) => store.setWalletDisconnected)\n  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus)\n  const setAddressSwitched = useWalletStore((store) => store.setAddressSwitched)\n  const currentAddress = useWalletStore((state) => state.currentAddress)\n  const sessions = useSession()\n  const curSession = useCurrentSession()\n  const setCurrentSession = useSessionStore((state) => state.setCurrentSession)\n\n  const accountsChangedHandler = useCallback(\n    async (address: string[]) => {\n      if (address.length === 0) {\n        setWalletDisconnected()\n      } else {\n        setConnectionStatus('connecting')\n        const selectedAddress = address[0]\n        if (selectedAddress !== currentAddress?.toStr()) {\n          setAddressSwitched(new BitcoinAddress(selectedAddress))\n          setCurrentSession(undefined)\n          const cur = sessions.find(\n            (item: Session) =>\n              item.getRoochAddress().toStr() === currentAddress?.genRoochAddress().toStr(),\n          )\n          if (cur && cur.getAuthKey() !== curSession?.getAuthKey()) {\n            setCurrentSession(cur)\n          }\n        }\n      }\n    },\n    [\n      sessions,\n      curSession,\n      currentAddress,\n      setAddressSwitched,\n      setConnectionStatus,\n      setCurrentSession,\n      setWalletDisconnected,\n    ],\n  )\n\n  // handle Listener\n  useEffect(() => {\n    if (connectionStatus === 'connected') {\n      currentWallet?.onAccountsChanged(accountsChangedHandler)\n    }\n\n    return () => {\n      if (connectionStatus === 'connected') {\n        currentWallet?.removeAccountsChanged(accountsChangedHandler)\n      }\n    }\n  }, [accountsChangedHandler, connectionStatus, currentWallet])\n\n  return children\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createStore } from 'zustand'\nimport { createJSONStorage, persist } from 'zustand/middleware'\nimport { StateStorage } from 'zustand/middleware'\nimport { ThirdPartyAddress } from '@roochnetwork/rooch-sdk'\n\nimport { SupportChain } from '../feature/index.js'\n\nimport { Wallet } from '../wellet/index.js'\n\ntype WalletConnectionStatus = 'disconnected' | 'connecting' | 'connected'\n\nexport type WalletActions = {\n  setChain: (chain: SupportChain) => void\n  setAddressSwitched: (selectedAccount: ThirdPartyAddress) => void\n  setConnectionStatus: (connectionStatus: WalletConnectionStatus) => void\n  setWalletConnected: (\n    wallet: Wallet,\n    connectedAddress: readonly ThirdPartyAddress[],\n    selectedAddress: ThirdPartyAddress | null,\n  ) => void\n  updateWalletAddresses: (accounts: readonly ThirdPartyAddress[]) => void\n  setWalletDisconnected: () => void\n  updateWallets: (wallets: readonly Wallet[]) => void\n}\n\nexport type WalletStore = ReturnType<typeof createWalletStore>\n\nexport type WalletStoreState = {\n  autoConnectEnabled: boolean\n  currentChain: SupportChain\n  currentWallet: Wallet | undefined\n  wallets: readonly Wallet[]\n  addresses: readonly ThirdPartyAddress[]\n  currentAddress: ThirdPartyAddress | undefined\n  lastConnectedAddress: string | undefined\n  lastConnectedWalletName: string | undefined\n  connectionStatus: WalletConnectionStatus\n} & WalletActions\n\ntype WalletConfiguration = {\n  autoConnectEnabled: boolean\n  chain: SupportChain\n  currentWallet: Wallet | undefined\n  wallets: Wallet[]\n  storage: StateStorage\n  storageKey: string\n}\n\nexport function createWalletStore({\n  chain,\n  currentWallet,\n  wallets,\n  storage,\n  storageKey,\n  autoConnectEnabled,\n}: WalletConfiguration) {\n  return createStore<WalletStoreState>()(\n    persist(\n      (set, get) => ({\n        currentChain: chain,\n        autoConnectEnabled,\n        currentWallet,\n        wallets,\n        addresses: [],\n        currentAddress: undefined,\n        lastConnectedAddress: undefined,\n        lastConnectedWalletName: undefined,\n        connectionStatus: 'disconnected',\n        setChain(chain) {\n          const currentChain = get().currentChain\n\n          if (currentChain === chain) {\n            return\n          }\n          set(() => ({\n            currentChain: chain,\n            accounts: [],\n            // currentWallet: supportWallets.find((v) => v.getSupportNetworks()),\n            sessionAccount: null,\n            connectionStatus: 'disconnected',\n          }))\n        },\n        setConnectionStatus(connectionStatus) {\n          set(() => ({\n            connectionStatus,\n          }))\n        },\n        setWalletConnected(wallet, connectedAddresses, selectedAddress) {\n          set(() => ({\n            currentWallet: wallet,\n            accounts: connectedAddresses,\n            currentAddress: selectedAddress || undefined,\n            lastConnectedWalletName: wallet.getName(),\n            lastConnectedAddress: selectedAddress?.toStr(),\n            connectionStatus: 'connected',\n          }))\n        },\n        setWalletDisconnected() {\n          set(() => ({\n            accounts: [],\n            currentAddress: undefined,\n            lastConnectedWalletName: undefined,\n            lastConnectedAddress: undefined,\n            connectionStatus: 'disconnected',\n          }))\n        },\n        setAddressSwitched(selected) {\n          set(() => ({\n            currentAddress: selected,\n            lastConnectedAddress: selected.toStr() ?? '',\n          }))\n        },\n        updateWalletAddresses(addresses) {\n          const currentAddr = get().currentAddress\n          set(() => ({\n            currentAddress:\n              (currentAddr && addresses.find((addr) => addr.toStr() === currentAddr.toStr())) ||\n              addresses[0],\n          }))\n        },\n        updateWallets(wallets) {\n          set(() => ({\n            wallets: wallets,\n          }))\n        },\n      }),\n      {\n        name: storageKey,\n        storage: createJSONStorage(() => storage),\n        partialize: ({ lastConnectedWalletName, lastConnectedAddress }) => ({\n          lastConnectedWalletName,\n          lastConnectedAddress,\n        }),\n      },\n    ),\n  )\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useContext } from 'react'\n\nimport { ClientContext, ClientProviderContext } from '../../provider/clientProvider.js'\n\nexport function useRoochContext(): ClientProviderContext {\n  const context = useContext(ClientContext)\n  if (!context) {\n    throw new Error(\n      'Could not find RoochClientContext. Ensure that you have set up the RoochClientProvider.',\n    )\n  }\n  return context\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useQuery } from '@tanstack/react-query'\nimport type { UseQueryOptions, UseQueryResult } from '@tanstack/react-query'\n\nimport type { RoochClient } from '@roochnetwork/rooch-sdk'\n\nimport type { PartialBy } from '../../types/index.js'\nimport { useRoochClient, useCurrentNetwork } from './index.js'\n\nexport type RpcMethodName = {\n  [K in keyof RoochClient]: RoochClient[K] extends\n    | ((input: any) => Promise<any>)\n    | (() => Promise<any>)\n    ? K\n    : never\n}[keyof RoochClient]\n\nexport type RpcMethods = {\n  [K in RpcMethodName]: RoochClient[K] extends (input: infer P) => Promise<infer R>\n    ? {\n        name: K\n        result: R\n        params: P\n      }\n    : RoochClient[K] extends () => Promise<infer R>\n      ? {\n          name: K\n          result: R\n          params: undefined | object\n        }\n      : never\n}\n\nexport type UseRoochClientQueryOptions<T extends keyof RpcMethods, TData> = PartialBy<\n  Omit<UseQueryOptions<RpcMethods[T]['result'], Error, TData, unknown[]>, 'queryFn'>,\n  'queryKey'\n>\n\nexport function useRoochClientQuery<T extends keyof RpcMethods, TData = RpcMethods[T]['result']>(\n  ...args: undefined extends RpcMethods[T]['params']\n    ? [method: T, params?: RpcMethods[T]['params'], options?: UseRoochClientQueryOptions<T, TData>]\n    : [method: T, params: RpcMethods[T]['params'], options?: UseRoochClientQueryOptions<T, TData>]\n): UseQueryResult<TData, Error> {\n  const [method, params, { queryKey = [], ...options } = {}] = args as [\n    method: T,\n    params?: RpcMethods[T]['params'],\n    options?: UseRoochClientQueryOptions<T, TData>,\n  ]\n\n  const network = useCurrentNetwork()\n  const roochClient = useRoochClient()\n\n  return useQuery({\n    ...options,\n    queryKey: [network, method, params, ...queryKey],\n    queryFn: async () => {\n      return await roochClient[method](params as never)\n    },\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\n\nimport { roochMutationKeys } from '../../constants/index.js'\nimport { useRoochContext } from './useRoochContext.js'\n\ntype UseSwitchNetworkArgs = string\n\ntype UseSwitchNetworkResult = void\n\ntype UseSwitchNetworkMutationOptions = Omit<\n  UseMutationOptions<UseSwitchNetworkResult, Error, UseSwitchNetworkArgs, unknown>,\n  'mutationFn'\n>\n\nexport function useSwitchNetwork({\n  mutationKey,\n  ...mutationOptions\n}: UseSwitchNetworkMutationOptions = {}): UseMutationResult<\n  UseSwitchNetworkResult,\n  Error,\n  UseSwitchNetworkArgs,\n  unknown\n> {\n  const switchNetwork = useRoochContext().selectNetwork\n\n  return useMutation({\n    mutationKey: roochMutationKeys.switchNetwork(mutationKey),\n    mutationFn: async (args) => {\n      switchNetwork(args)\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { MutationKey } from '@tanstack/react-query'\n\nfunction formMutationKeyFn(baseEntity: string) {\n  return function mutationKeyFn(additionalKeys: MutationKey = []) {\n    return [{ ...roochMutationKeys.all, baseEntity }, ...additionalKeys]\n  }\n}\n\nexport const roochMutationKeys = {\n  all: { baseScope: 'rooch' },\n  addNetwork: formMutationKeyFn('add-network'),\n  switchNetwork: formMutationKeyFn('switch-network'),\n  removeNetwork: formMutationKeyFn('remove-network'),\n  removeSession: formMutationKeyFn('remove-session'),\n  transferObject: formMutationKeyFn('transfer-object'),\n  transferCoin: formMutationKeyFn('transfer-coin'),\n  signAndExecuteTransaction: formMutationKeyFn('sign-and-execute-transaction'),\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { MutationKey } from '@tanstack/react-query'\n\nfunction formMutationKeyFn(baseEntity: string) {\n  return function mutationKeyFn(additionalKeys: MutationKey = []) {\n    return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys]\n  }\n}\n\nexport const walletMutationKeys = {\n  all: { baseScope: 'wallet' },\n  connectWallet: formMutationKeyFn('connect-wallet'),\n  autoConnectWallet: formMutationKeyFn('auto-connect-wallet'),\n  switchAccount: formMutationKeyFn('switch-account'),\n  createSessionKey: formMutationKeyFn('create-session-key'),\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Signer, TypeArgs } from '@roochnetwork/rooch-sdk'\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\n\nimport { useRoochClient } from './useRoochClient.js'\nimport { roochMutationKeys } from '../../constants/index.js'\n\ntype UseTransferObjectArgs = {\n  signer: Signer\n  recipient: string\n  objectId: string\n  objectType: TypeArgs\n}\n\ntype UseTransferObjectResult = void\n\ntype UseSwitchNetworkMutationOptions = Omit<\n  UseMutationOptions<UseTransferObjectResult, Error, UseTransferObjectArgs, unknown>,\n  'mutationFn'\n>\n\nexport function useTransferObject({\n  mutationKey,\n  ...mutationOptions\n}: UseSwitchNetworkMutationOptions = {}): UseMutationResult<\n  UseTransferObjectResult,\n  Error,\n  UseTransferObjectArgs,\n  unknown\n> {\n  const client = useRoochClient()\n\n  return useMutation({\n    mutationKey: roochMutationKeys.transferObject(mutationKey),\n    mutationFn: async (args) => {\n      const result = await client.transferObject(args)\n\n      if (result.execution_info.status.type !== 'executed') {\n        Error('transfer failed' + result.execution_info.status.type)\n      }\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\nimport { address, TypeArgs, Signer } from '@roochnetwork/rooch-sdk'\n\nimport { roochMutationKeys } from '../../constants/index.js'\nimport { useRoochClient } from './index.js'\nimport { useCurrentSession } from '../useCurrentSession.js'\n\ntype UseTransferCoinArgs = {\n  signer?: Signer\n  recipient: address\n  amount: number | bigint\n  coinType: TypeArgs\n}\n\ntype UseTransferCoinResult = void\n\ntype UseSwitchNetworkMutationOptions = Omit<\n  UseMutationOptions<UseTransferCoinResult, Error, UseTransferCoinArgs, unknown>,\n  'mutationFn'\n>\n\nexport function useTransferCoin({\n  mutationKey,\n  ...mutationOptions\n}: UseSwitchNetworkMutationOptions = {}): UseMutationResult<\n  UseTransferCoinResult,\n  Error,\n  UseTransferCoinArgs,\n  unknown\n> {\n  const client = useRoochClient()\n  const curSession = useCurrentSession()\n\n  return useMutation({\n    mutationKey: roochMutationKeys.transferCoin(mutationKey),\n    mutationFn: async (args) => {\n      const signer = args.signer || curSession\n\n      if (signer === null) {\n        throw Error('')\n      }\n\n      const result = await client.transfer({\n        ...args,\n        signer: args.signer || curSession!,\n      })\n\n      if (result.execution_info.status.type !== 'executed') {\n        Error('transfer failed' + result.execution_info.status.type)\n      }\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { UseMutationOptions, UseMutationResult, useMutation } from '@tanstack/react-query'\n\nimport { Signer, Transaction, ExecuteTransactionResponseView } from '@roochnetwork/rooch-sdk'\n\nimport { useRoochClient } from './useRoochClient.js'\nimport { roochMutationKeys } from '../../constants/index.js'\nimport { useCurrentSession } from '../useCurrentSession.js'\n\ntype UseSignAndExecuteTransactionArgs = {\n  transaction: Transaction\n  signer?: Signer\n}\n\ntype UsesignAndExecuteTransactionResult = ExecuteTransactionResponseView\n\ntype UsesignAndExecuteTransactionOptions = Omit<\n  UseMutationOptions<\n    UsesignAndExecuteTransactionResult,\n    Error,\n    UseSignAndExecuteTransactionArgs,\n    unknown\n  >,\n  'mutationFn'\n>\n\nexport function UseSignAndExecuteTransaction({\n  mutationKey,\n  ...mutationOptions\n}: UsesignAndExecuteTransactionOptions = {}): UseMutationResult<\n  UsesignAndExecuteTransactionResult,\n  Error,\n  UseSignAndExecuteTransactionArgs,\n  unknown\n> {\n  const client = useRoochClient()\n  const session = useCurrentSession()\n\n  return useMutation({\n    mutationKey: roochMutationKeys.signAndExecuteTransaction(mutationKey),\n    mutationFn: async (args) => {\n      if (!session) {\n        throw Error('Create a session first')\n      }\n\n      const result = await client.signAndExecuteTransaction({\n        transaction: args.transaction,\n        signer: args.signer || session,\n      })\n\n      if (result.execution_info.status.type !== 'executed' && result.execution_info.status) {\n        Error('transfer failed' + result.execution_info.status.type)\n      }\n\n      return result\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\n\nimport { Session } from '@roochnetwork/rooch-sdk'\nimport { roochMutationKeys } from '../constants/index.js'\nimport { useCurrentSession, useRoochClient, useSession } from './index.js'\nimport { useSessionStore } from './useSessionsStore.js'\n\ntype UseRemoveSessionArgs = {\n  authKey: string\n}\n\ntype UseRemoveSessionResult = void\n\ntype UseRemoveSessionMutationOptions = Omit<\n  UseMutationOptions<UseRemoveSessionResult, Error, UseRemoveSessionArgs, unknown>,\n  'mutationFn'\n>\n\nexport function useRemoveSession({\n  mutationKey,\n  ...mutationOptions\n}: UseRemoveSessionMutationOptions = {}): UseMutationResult<\n  UseRemoveSessionResult,\n  Error,\n  UseRemoveSessionArgs,\n  unknown\n> {\n  const sessionsKeys = useSession()\n  const removeSession = useSessionStore((state) => state.removeSession)\n  const setCurrentSession = useSessionStore((state) => state.setCurrentSession)\n  const currentSession = useCurrentSession()\n  const client = useRoochClient()\n  const curSessionKey = useCurrentSession()\n\n  return useMutation({\n    mutationKey: roochMutationKeys.removeSession(mutationKey),\n    mutationFn: async (args) => {\n      try {\n        if (!curSessionKey) {\n          return\n        }\n\n        const result = await client.removeSession({\n          authKey: args.authKey,\n          signer: curSessionKey,\n        })\n\n        if (result) {\n          // clean cache\n          let cacheSession = sessionsKeys.find(\n            (item: Session) => item.getAuthKey() === args.authKey,\n          )\n\n          if (cacheSession) {\n            removeSession(cacheSession)\n            if (cacheSession.getAuthKey() === currentSession?.getAuthKey()) {\n              setCurrentSession(undefined)\n            }\n          }\n        }\n      } catch (e) {\n        throw e\n      }\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useQuery } from '@tanstack/react-query'\nimport { useLayoutEffect, useState } from 'react'\n\nimport {\n  useWalletStore,\n  useConnectWallet,\n  useWallets,\n  useCurrentWallet,\n  useCurrentAddress,\n} from './index.js'\n\nexport function useAutoConnectWallet(): 'disabled' | 'idle' | 'attempted' {\n  const { mutateAsync: connectWallet } = useConnectWallet()\n  const autoConnectEnabled = useWalletStore((state) => state.autoConnectEnabled)\n  const lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName)\n  const lastConnectedAddress = useWalletStore((state) => state.lastConnectedAddress)\n  const { isConnected } = useCurrentWallet()\n  const wallets = useWallets()\n  const [clientOnly, setClientOnly] = useState(false)\n  const currentAddress = useCurrentAddress()\n\n  useLayoutEffect(() => {\n    setClientOnly(true)\n  }, [])\n\n  const { data, isError } = useQuery({\n    queryKey: [\n      '@rooch/sdk-kit',\n      'autoconnect',\n      {\n        isConnected,\n        autoConnectEnabled,\n        lastConnectedWalletName,\n        lastConnectedAddress,\n      },\n    ],\n    queryFn: async () => {\n      if (!autoConnectEnabled) {\n        return 'disabled'\n      }\n\n      if (!lastConnectedWalletName || !lastConnectedAddress || isConnected) {\n        return 'attempted'\n      }\n\n      let wallet = wallets.find((wallet) => wallet.getName() === lastConnectedWalletName)\n\n      if (wallet) {\n        await connectWallet({ wallet })\n        if (wallet.getChain() !== 'bitcoin' && currentAddress?.toStr() !== lastConnectedAddress) {\n          wallet.switchAccount(lastConnectedAddress)\n        }\n      }\n\n      return 'attempted'\n    },\n    enabled: autoConnectEnabled,\n    persister: undefined,\n    gcTime: 0,\n    staleTime: 0,\n    networkMode: 'always',\n    retry: (failureCount) => {\n      // Retry only if there is a wallet to connect and we haven't exceeded 3 attempts\n      if (\n        wallets.find((wallet) => wallet.getName() === lastConnectedWalletName) &&\n        failureCount < 3\n      ) {\n        return true\n      }\n      return false\n    },\n    retryOnMount: false,\n    refetchInterval: 1000,\n    refetchIntervalInBackground: false,\n    refetchOnMount: false,\n    refetchOnReconnect: false,\n    refetchOnWindowFocus: false,\n  })\n\n  if (!autoConnectEnabled) {\n    return 'disabled'\n  }\n\n  // We always initialize with \"idle\" so that in SSR environments, we guarantee that the initial render states always agree:\n  if (!clientOnly) {\n    return 'idle'\n  }\n\n  if (!lastConnectedWalletName) {\n    return 'attempted'\n  }\n\n  return isError ? 'attempted' : data ?? 'idle'\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\nimport { ThirdPartyAddress, Session } from '@roochnetwork/rooch-sdk'\n\nimport { useWalletStore } from './useWalletStore.js'\nimport { walletMutationKeys } from '../../constants/index.js'\nimport { Wallet } from '../../wellet/index.js'\nimport { useSessionStore } from '../useSessionsStore.js'\nimport { useSession } from '../useSessions.js'\n\ntype ConnectWalletArgs = {\n  wallet: Wallet\n}\ntype ConnectWalletResult = ThirdPartyAddress[]\n\ntype UseConnectWalletMutationOptions = Omit<\n  UseMutationOptions<ConnectWalletResult, Error, ConnectWalletArgs, unknown>,\n  'mutationFn'\n>\n\n/**\n * Mutation hook for establishing a connection to a specific wallet.\n *\n */\nexport function useConnectWallet({\n  mutationKey,\n  ...mutationOptions\n}: UseConnectWalletMutationOptions = {}): UseMutationResult<\n  ConnectWalletResult,\n  Error,\n  ConnectWalletArgs,\n  unknown\n> {\n  const sessions = useSession()\n  const setCurrentSession = useSessionStore((state) => state.setCurrentSession)\n  const setWalletConnected = useWalletStore((state) => state.setWalletConnected)\n  const setConnectionStatus = useWalletStore((state) => state.setConnectionStatus)\n\n  return useMutation({\n    mutationKey: walletMutationKeys.connectWallet(mutationKey),\n    mutationFn: async ({ wallet }) => {\n      try {\n        setConnectionStatus('connecting')\n\n        const connectAddress = await wallet.connect()\n        const selectedAddress = connectAddress[0]\n\n        setWalletConnected(wallet, connectAddress, selectedAddress)\n\n        const cur = sessions.find(\n          (item: Session) =>\n            item.getRoochAddress().toStr() === selectedAddress?.genRoochAddress().toStr(),\n        )\n\n        setCurrentSession(cur)\n\n        return connectAddress\n      } catch (error) {\n        setConnectionStatus('disconnected')\n        throw error\n      }\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query'\nimport { useMutation } from '@tanstack/react-query'\nimport { Session } from '@roochnetwork/rooch-sdk'\nimport type { CreateSessionArgs } from '@roochnetwork/rooch-sdk'\n\nimport { useRoochClient } from '../client/index.js'\nimport { useCurrentWallet } from './useCurrentWallet.js'\nimport { walletMutationKeys } from '../../constants/index.js'\nimport { WalletNotConnectedError } from '../../error/walletErrors.js'\nimport { useSessionStore } from '../useSessionsStore.js'\n\ntype UseCreateSessionKeyArgs = CreateSessionArgs\n\ntype UseCreateSessionKeyError = WalletNotConnectedError | Error\n\ntype UseCreateSessionKeyResult = Session | null\n\ntype UseCreateSessionKeyMutationOptions = Omit<\n  UseMutationOptions<\n    UseCreateSessionKeyResult,\n    UseCreateSessionKeyError,\n    UseCreateSessionKeyArgs,\n    unknown\n  >,\n  'mutationFn'\n>\n\nexport function useCreateSessionKey({\n  mutationKey,\n  ...mutationOptions\n}: UseCreateSessionKeyMutationOptions = {}): UseMutationResult<\n  UseCreateSessionKeyResult,\n  UseCreateSessionKeyError,\n  UseCreateSessionKeyArgs,\n  unknown\n> {\n  const client = useRoochClient()\n  const currentWallet = useCurrentWallet()\n  const setCurrentSession = useSessionStore((state) => state.setCurrentSession)\n\n  return useMutation({\n    mutationKey: walletMutationKeys.createSessionKey(mutationKey),\n    mutationFn: async (args) => {\n      if (!currentWallet.isConnected) {\n        throw new WalletNotConnectedError('No wallet is connected.')\n      }\n\n      const sessionAccount = await client.createSession({\n        signer: currentWallet.wallet!,\n        sessionArgs: args,\n      })\n\n      setCurrentSession(sessionAccount)\n\n      return sessionAccount\n    },\n    ...mutationOptions,\n  })\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Wallet } from '../../wellet/index.js'\nimport { useWalletStore } from './useWalletStore.js'\nimport { useEffect } from 'react'\nimport { getWallets } from '../../wellet/wallets.js'\nimport { getRegisteredWallets } from '../../wellet/util.js'\n\n/**\n * Retrieves all wallets\n */\nexport function useWalletChanged(\n  preferredWallets: string[],\n  walletFilter?: (wallet: Wallet) => boolean,\n) {\n  const updateWallets = useWalletStore((state) => state.updateWallets)\n\n  useEffect(() => {\n    const api = getWallets()\n    updateWallets(getRegisteredWallets(preferredWallets, walletFilter))\n\n    const unsubscribeFromRegister = api.on('register', () => {\n      updateWallets(getRegisteredWallets(preferredWallets, walletFilter))\n    })\n\n    return () => {\n      unsubscribeFromRegister()\n    }\n  }, [preferredWallets, updateWallets, walletFilter])\n}\n", "// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useWalletStore } from './index.js'\n\n/**\n * Retrieves all wallets\n */\nexport function useCurrentAddress() {\n  return useWalletStore((state) => state.currentAddress)\n}\n"],
  "mappings": ";AAGA,SAAS,cAAAA,mBAAkB;AAC3B,SAAS,YAAAC,iBAAgB;;;ACAzB,SAAS,iBAAAC,gBAAe,cAAc;;;ACDtC,SAAoB,mBAAmB;AAEvC,SAAS,eAAe,SAAS,gBAAgB;AAEjD;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OAEK;;;ACTP,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;;;ACDzB;AAAA,EACE;AAAA,EAGA;AAAA,EACA;AAAA,OACK;;;AF0GE;AAtFF,IAAM,gBAAgB,cAA4C,IAAI;AAiB7E,IAAM,mBAAmB;AAAA,EACvB,UAAU,EAAE,KAAK,gBAAgB,UAAU,EAAE;AAC/C;;;AG7CA,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB,eAA6B;AACzD,SAAS,eAAe;;;ACFxB,SAAmC,cAAc;;;ACAjD;AAAA,EAEE;AAAA,EAEA;AAAA,EAGA;AAAA,EAEA;AAAA,OAEK;;;ACXP,SAAS,kBAAAC,iBAA0C,KAAK,aAAa;;;ACArE,SAAS,kBAAAC,iBAA0C,OAAAC,MAAK,SAAAC,cAAa;;;ACArE,SAAS,kBAAAC,iBAA0C,OAAAC,MAAK,SAAAC,cAAa;;;ATyC/D,gBAAAC,YAAA;AA9BC,IAAM,eAAeC,eAAmC,IAAI;;;AUXnE,SAAoB,eAAAC,cAAa,iBAAAC,gBAAe,WAAW,UAAAC,eAAc;AAEzE,SAAS,kBAAAC,uBAA+B;;;ACFxC,SAAS,eAAAC,oBAAmB;AAC5B,SAAS,qBAAAC,oBAAmB,WAAAC,gBAAe;;;ACD3C,SAAS,cAAAC,mBAAkB;;;ACA3B,SAAS,gBAAgB;;;ACCzB,SAAS,mBAAmB;;;ACC5B,SAAS,kBAAkB,YAAoB;AAC7C,SAAO,SAAS,cAAc,iBAA8B,CAAC,GAAG;AAC9D,WAAO,CAAC,EAAE,GAAG,kBAAkB,KAAK,WAAW,GAAG,GAAG,cAAc;AAAA,EACrE;AACF;AAEO,IAAM,oBAAoB;AAAA,EAC/B,KAAK,EAAE,WAAW,QAAQ;AAAA,EAC1B,YAAY,kBAAkB,aAAa;AAAA,EAC3C,eAAe,kBAAkB,gBAAgB;AAAA,EACjD,eAAe,kBAAkB,gBAAgB;AAAA,EACjD,eAAe,kBAAkB,gBAAgB;AAAA,EACjD,gBAAgB,kBAAkB,iBAAiB;AAAA,EACnD,cAAc,kBAAkB,eAAe;AAAA,EAC/C,2BAA2B,kBAAkB,8BAA8B;AAC7E;;;ACfA,SAASC,mBAAkB,YAAoB;AAC7C,SAAO,SAAS,cAAc,iBAA8B,CAAC,GAAG;AAC9D,WAAO,CAAC,EAAE,GAAG,mBAAmB,KAAK,WAAW,GAAG,GAAG,cAAc;AAAA,EACtE;AACF;AAEO,IAAM,qBAAqB;AAAA,EAChC,KAAK,EAAE,WAAW,SAAS;AAAA,EAC3B,eAAeA,mBAAkB,gBAAgB;AAAA,EACjD,mBAAmBA,mBAAkB,qBAAqB;AAAA,EAC1D,eAAeA,mBAAkB,gBAAgB;AAAA,EACjD,kBAAkBA,mBAAkB,oBAAoB;AAC1D;;;ACZA,SAAS,eAAAC,oBAAmB;;;ACD5B,SAAS,eAAAC,oBAAmB;;;ACD5B,SAAgD,eAAAC,oBAAmB;;;ACCnE,SAAS,eAAAC,oBAAmB;;;AVuEtB,gBAAAC,YAAA;AAlCC,IAAM,gBAAgBC,eAAkC,IAAI;;;AXhC5D,SAAS,eAAkB,UAA6C;AAC7E,QAAM,QAAQC,YAAW,aAAa;AACtC,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,+EAA+E;AAAA,EACjG;AACA,SAAOC,UAAS,OAAO,QAAQ;AACjC;;;AsBZA,SAAS,YAAAC,iBAAgB;AACzB,SAAS,iBAAiB,YAAAC,iBAAgB;;;ACA1C,SAAS,eAAAC,oBAAmB;;;ACA5B,SAAS,eAAAC,oBAAmB;;;ACC5B,SAAS,aAAAC,kBAAiB;;;ACGnB,SAAS,oBAAoB;AAClC,SAAO,eAAe,CAAC,UAAU,MAAM,cAAc;AACvD;",
  "names": ["useContext", "useStore", "createContext", "BitcoinAddress", "BitcoinAddress", "str", "bytes", "BitcoinAddress", "str", "bytes", "jsx", "createContext", "useCallback", "createContext", "useRef", "BitcoinAddress", "createStore", "createJSONStorage", "persist", "useContext", "formMutationKeyFn", "useMutation", "useMutation", "useMutation", "useMutation", "jsx", "createContext", "useContext", "useStore", "useQuery", "useState", "useMutation", "useMutation", "useEffect"]
}
