"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var util_exports = {};
__export(util_exports, {
  canonicalRoochAddress: () => canonicalRoochAddress,
  convertToRoochAddressBytes: () => convertToRoochAddressBytes,
  decodeToRoochAddressStr: () => decodeToRoochAddressStr,
  isValidAddress: () => isValidAddress,
  isValidBitcoinAddress: () => isValidBitcoinAddress,
  isValidRoochAddress: () => isValidRoochAddress,
  normalizeRoochAddress: () => normalizeRoochAddress
});
module.exports = __toCommonJS(util_exports);
var import_base = require("@scure/base");
var import_bytes = require("../utils/bytes.js");
var import_hex = require("../utils/hex.js");
var import_bitcoin = require("./bitcoin.js");
var import_address = require("./address.js");
function decodeToRoochAddressStr(input) {
  if (typeof input === "string") {
    if (isValidRoochAddress(input)) {
      return input;
    }
    if (isValidBitcoinAddress(input)) {
      return new import_bitcoin.BitcoinAddress(input).genRoochAddress().toHexAddress();
    }
    throw Error("Invalid Address");
  }
  if ((0, import_bytes.isBytes)(input)) {
    return (0, import_bytes.str)("hex", input);
  }
  return decodeToRoochAddressStr(input.toStr());
}
function convertToRoochAddressBytes(input) {
  if (typeof input === "string") {
    const normalizeAddress = normalizeRoochAddress(input);
    if ((0, import_hex.isHex)(normalizeAddress) && (0, import_hex.getHexByteLength)(normalizeAddress) === import_address.ROOCH_ADDRESS_LENGTH) {
      return (0, import_hex.fromHEX)(normalizeAddress);
    }
    if (input.startsWith(import_address.ROOCH_BECH32_PREFIX)) {
      const decode = import_base.bech32m.decode(input);
      const bytes = import_base.bech32m.fromWords(decode.words);
      if (decode.prefix === import_address.ROOCH_BECH32_PREFIX && bytes.length === import_address.ROOCH_ADDRESS_LENGTH) {
        return bytes;
      }
    }
    return new import_bitcoin.BitcoinAddress(input).genRoochAddress().toBytes();
  }
  return (0, import_bytes.isBytes)(input) ? input : convertToRoochAddressBytes(input.toStr());
}
function isValidBitcoinAddress(input) {
  try {
    new import_bitcoin.BitcoinAddress(input);
    return true;
  } catch (_) {
  }
  return false;
}
function isValidRoochAddress(input) {
  if (typeof input === "string") {
    const normalizeAddress = normalizeRoochAddress(input);
    if ((0, import_hex.isHex)(normalizeAddress) && (0, import_hex.getHexByteLength)(normalizeAddress) === import_address.ROOCH_ADDRESS_LENGTH) {
      return true;
    }
    if (input.startsWith(import_address.ROOCH_BECH32_PREFIX)) {
      const decode = import_base.bech32m.decode(input);
      const bytes = import_base.bech32m.fromWords(decode.words);
      return decode.prefix === import_address.ROOCH_BECH32_PREFIX && bytes.length === import_address.ROOCH_ADDRESS_LENGTH;
    }
    return false;
  }
  return (0, import_bytes.isBytes)(input) ? input.length === import_address.ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr());
}
function isValidAddress(input) {
  if (typeof input === "string") {
    if (isValidRoochAddress(input)) {
      return true;
    }
    return isValidBitcoinAddress(input);
  }
  return (0, import_bytes.isBytes)(input) ? input.length === import_address.ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr());
}
function normalizeRoochAddress(input, forceAdd0x = false) {
  let address2 = input.toLowerCase();
  if (!forceAdd0x && address2.startsWith("0x")) {
    address2 = address2.slice(2);
  }
  return `0x${address2.padStart(import_address.ROOCH_ADDRESS_LENGTH * 2, "0")}`;
}
function canonicalRoochAddress(input, forceAdd0x = false) {
  return normalizeRoochAddress(input, forceAdd0x).slice(2);
}
//# sourceMappingURL=util.js.map
