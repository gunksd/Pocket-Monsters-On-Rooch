"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var hex_exports = {};
__export(hex_exports, {
  fromHEX: () => fromHEX,
  getHexByteLength: () => getHexByteLength,
  isHex: () => isHex,
  normalizeHex: () => normalizeHex,
  toHEX: () => toHEX
});
module.exports = __toCommonJS(hex_exports);
function isHex(input) {
  if (typeof input === "string") {
    return /^(0x|0X)?[a-fA-F0-9]+$/.test(input) && input.length % 2 === 0;
  } else {
    for (let i = 0; i < input.length; i++) {
      const byte = input[i];
      if (!(byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102)) {
        return false;
      }
    }
    return true;
  }
}
function getHexByteLength(input) {
  return /^(0x|0X)/.test(input) ? (input.length - 2) / 2 : input.length / 2;
}
function normalizeHex(input) {
  return input.startsWith("0x") ? input.slice(2) : input;
}
function fromHEX(input) {
  const normalized = normalizeHex(input);
  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;
  const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];
  return Uint8Array.from(intArr);
}
const u8a = (a) => a instanceof Uint8Array;
const hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function toHEX(input) {
  if (!u8a(input))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < input.length; i++) {
    hex += hexes[input[i]];
  }
  return hex;
}
//# sourceMappingURL=hex.js.map
