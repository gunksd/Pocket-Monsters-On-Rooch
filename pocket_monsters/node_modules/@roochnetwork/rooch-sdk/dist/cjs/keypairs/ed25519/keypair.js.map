{
  "version": 3,
  "sources": ["../../../../src/keypairs/ed25519/keypair.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl'\n\nimport { BitcoinAddress, RoochAddress } from '../../address/index.js'\nimport { Bytes } from '../../types/index.js'\nimport {\n  Authenticator,\n  encodeRoochSercetKey,\n  isValidHardenedPath,\n  Keypair,\n  mnemonicToSeedHex,\n  PRIVATE_KEY_SIZE,\n  decodeRoochSercetKey,\n  SignatureScheme,\n} from '../../crypto/index.js'\n\nimport { derivePath } from './ed25519-hd-key.js'\nimport { Ed25519PublicKey } from './publickey.js'\nimport { Transaction } from '../../transactions/index.js'\n\nexport const DEFAULT_ED25519_DERIVATION_PATH = `m/44'/784'/0'/0'/0'`\n\n/**\n * Ed25519 Keypair data. The publickey is the 32-byte public key and\n * the secretkey is 64-byte, where the first 32 bytes is the secret\n * key and the last 32 bytes is the public key.\n */\nexport interface Ed25519KeypairData {\n  publicKey: Bytes\n  secretKey: Bytes\n}\n\n/**\n * An Ed25519 Keypair used for signing transactions.\n */\nexport class Ed25519Keypair extends Keypair {\n  private keypair: Ed25519KeypairData\n\n  /**\n   * Create a new Ed25519 keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param keypair Ed25519 keypair\n   */\n  constructor(keypair?: Ed25519KeypairData) {\n    super()\n    if (keypair) {\n      this.keypair = keypair\n    } else {\n      this.keypair = nacl.sign.keyPair()\n    }\n  }\n\n  /**\n   * Get the key scheme of the keypair ED25519\n   */\n  getKeyScheme(): SignatureScheme {\n    return 'ED25519'\n  }\n\n  /**\n   * Generate a new random Ed25519 keypair\n   */\n  static generate(): Ed25519Keypair {\n    return new Ed25519Keypair(nacl.sign.keyPair())\n  }\n\n  /**\n   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n   * This is NOT the private scalar which is result of hashing and bit clamping of\n   * the raw secret key.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param skipValidation skip secret key validation\n   */\n  static fromSecretKey(secretKey: Uint8Array | string, skipValidation?: boolean): Ed25519Keypair {\n    const decodeSecretKey =\n      typeof secretKey === 'string'\n        ? (() => {\n            const decoded = decodeRoochSercetKey(secretKey)\n            if (decoded.schema !== 'ED25519') {\n              throw new Error('provided secretKey is invalid')\n            }\n            return decoded.secretKey\n          })()\n        : secretKey\n\n    const secretKeyLength = decodeSecretKey.length\n    if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n      throw new Error(\n        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`,\n      )\n    }\n    const keypair = nacl.sign.keyPair.fromSeed(decodeSecretKey)\n    if (!skipValidation) {\n      const encoder = new TextEncoder()\n      const signData = encoder.encode('rooch validation')\n      const signature = nacl.sign.detached(signData, keypair.secretKey)\n      if (!nacl.sign.detached.verify(signData, signature, keypair.publicKey)) {\n        throw new Error('provided secretKey is invalid')\n      }\n    }\n    return new Ed25519Keypair(keypair)\n  }\n\n  getBitcoinAddress(): BitcoinAddress {\n    throw new Error('Method not implemented in Ed25519.')\n  }\n\n  getRoochAddress(): RoochAddress {\n    return this.getPublicKey().toAddress()\n  }\n\n  /**\n   * The public key for this Ed25519 keypair\n   */\n  getPublicKey(): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.keypair.publicKey)\n  }\n\n  /**\n   * The Bech32 secret key string for this Ed25519 keypair\n   */\n  getSecretKey(): string {\n    return encodeRoochSercetKey(\n      this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),\n      this.getKeyScheme(),\n    )\n  }\n\n  /**\n   * Return the signature for the provided data using Ed25519.\n   */\n  async sign(input: Bytes) {\n    return nacl.sign.detached(input, this.keypair.secretKey)\n  }\n\n  signTransaction(input: Transaction): Promise<Authenticator> {\n    return Authenticator.rooch(input.hashData(), this)\n  }\n\n  /**\n   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypair(mnemonics: string, path?: string): Ed25519Keypair {\n    const newPath = path ?? DEFAULT_ED25519_DERIVATION_PATH\n\n    if (!isValidHardenedPath(newPath)) {\n      throw new Error('Invalid derivation path')\n    }\n    const { key } = derivePath(newPath, mnemonicToSeedHex(mnemonics))\n\n    return Ed25519Keypair.fromSecretKey(key)\n  }\n\n  /**\n   * Derive Ed25519 keypair from mnemonicSeed and path.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypairFromSeed(seedHex: string, path?: string): Ed25519Keypair {\n    const newPath = path ?? DEFAULT_ED25519_DERIVATION_PATH\n\n    if (!isValidHardenedPath(newPath)) {\n      throw new Error('Invalid derivation path')\n    }\n    const { key } = derivePath(newPath, seedHex)\n\n    return Ed25519Keypair.fromSecretKey(key)\n  }\n}\n"],
  "mappings": "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",
  "names": ["nacl"]
}
