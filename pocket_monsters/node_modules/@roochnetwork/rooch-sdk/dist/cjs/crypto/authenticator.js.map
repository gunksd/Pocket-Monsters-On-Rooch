{
  "version": 3,
  "sources": ["../../../src/crypto/authenticator.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../bcs/index.js'\nimport { Bytes } from '../types/index.js'\nimport { bytes, sha256, toHEX, concatBytes, varintByteNum } from '../utils/index.js'\n\nimport { Signer } from './signer.js'\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signatureScheme.js'\n\nconst BitcoinMessagePrefix = '\\u0018Bitcoin Signed Message:\\n'\nconst MessageInfoPrefix = 'Rooch Transaction:\\n'\n\nexport class BitcoinSignMessage {\n  readonly messagePrefix: string\n  readonly messageInfo: string\n  readonly txHash: Bytes\n\n  constructor(txData: Bytes, messageInfo: string) {\n    this.messagePrefix = BitcoinMessagePrefix\n    let msg = messageInfo.startsWith(MessageInfoPrefix)\n      ? messageInfo\n      : MessageInfoPrefix + messageInfo\n\n    msg = msg.charAt(msg.length - 1) !== '\\n' ? msg + '\\n' : msg\n\n    this.messageInfo = msg\n\n    this.txHash = txData\n  }\n\n  raw(): string {\n    return this.messageInfo + toHEX(this.txHash)\n  }\n\n  encode(): Bytes {\n    const msgHex = bytes('utf8', toHEX(this.txHash))\n    // Convert each part to Uint8Array\n    const infoBytes = bytes('utf8', this.messageInfo)\n    const prefixBytes = concatBytes(\n      bytes('utf8', this.messagePrefix),\n      varintByteNum(infoBytes.length + msgHex.length),\n    )\n\n    // Calculate the total length\n    const totalLength = prefixBytes.length + infoBytes.length + msgHex.length\n\n    // Create a new Uint8Array to hold all the data\n    const data = new Uint8Array(totalLength)\n\n    // Copy each part into the new array\n    let offset = 0\n    data.set(prefixBytes, offset)\n    offset += prefixBytes.length\n    data.set(infoBytes, offset)\n    offset += infoBytes.length\n    data.set(msgHex, offset)\n\n    return data\n  }\n\n  hash(): Bytes {\n    return sha256(this.encode())\n  }\n}\n\nexport enum BuiltinAuthValidator {\n  ROOCH = 0x00,\n  BITCOIN = 0x01,\n  // ETHEREUM= 0x02\n}\n\nexport class Authenticator {\n  readonly authValidatorId: number\n  readonly payload: Bytes\n\n  private constructor(authValidatorId: number, payload: Bytes) {\n    this.authValidatorId = authValidatorId\n    this.payload = payload\n  }\n\n  encode(): Bytes {\n    return bcs.Authenticator.serialize({\n      authValidatorId: this.authValidatorId,\n      payload: this.payload,\n    }).toBytes()\n  }\n\n  static async rooch(input: Bytes, signer: Signer) {\n    const signature = await signer.sign(input)\n    const pubKeyBytes = signer.getPublicKey().toBytes()\n    const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length)\n    serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signer.getKeyScheme()]])\n    serializedSignature.set(signature, 1)\n    serializedSignature.set(signer.getPublicKey().toBytes(), 1 + signature.length)\n\n    return new Authenticator(BuiltinAuthValidator.ROOCH, serializedSignature)\n  }\n\n  static async bitcoin(\n    input: BitcoinSignMessage,\n    signer: Signer,\n    signWith: 'hash' | 'raw' = 'hash',\n  ): Promise<Authenticator> {\n    if (!input.messageInfo.startsWith(MessageInfoPrefix)) {\n      throw Error('invalid message info')\n    }\n\n    const messageLength = bytes('utf8', input.messageInfo).length + toHEX(input.txHash).length\n    const sign = await signer.sign(signWith === 'hash' ? input.hash() : bytes('utf8', input.raw()))\n\n    const payload = bcs.BitcoinAuthPayload.serialize({\n      signature: sign,\n      messagePrefix: concatBytes(bytes('utf8', input.messagePrefix), varintByteNum(messageLength)),\n      messageInfo: bytes('utf8', input.messageInfo),\n      publicKey: signer.getPublicKey().toBytes(),\n      fromAddress: bytes('utf8', signer.getBitcoinAddress().toStr()),\n    }).toBytes()\n\n    return new Authenticator(BuiltinAuthValidator.BITCOIN, payload)\n  }\n}\n"],
  "mappings": "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",
  "names": ["BuiltinAuthValidator"]
}
