"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var session_exports = {};
__export(session_exports, {
  Session: () => Session
});
module.exports = __toCommonJS(session_exports);
var import_bcs = require("../bcs/index.js");
var import_keypairs = require("../keypairs/index.js");
var import_transactions = require("../transactions/index.js");
var import_address = require("../address/index.js");
var import_crypto = require("../crypto/index.js");
var import_utils = require("../utils/index.js");
const DEFAULT_MAX_INACTIVE_INTERVAL = 1200;
const REQUIRED_SCOPE = "0x3::session_key::remove_session_key_entry";
class Session extends import_crypto.Signer {
  constructor(appName, appUrl, scopes, roochAddress, bitcoinAddress, keypair, maxInactiveInterval, localCreateSessionTime, lastActiveTime) {
    super();
    this.appName = appName;
    this.appUrl = appUrl;
    this.scopes = scopes;
    this.roochAddress = roochAddress;
    this.bitcoinAddress = bitcoinAddress;
    this.keypair = keypair ?? import_keypairs.Ed25519Keypair.generate();
    this.maxInactiveInterval = maxInactiveInterval ?? DEFAULT_MAX_INACTIVE_INTERVAL;
    this.localCreateSessionTime = localCreateSessionTime ?? Date.now();
    this.lastActiveTime = lastActiveTime || this.localCreateSessionTime;
  }
  static async CREATE(input) {
    const parsedScopes = input.scopes.map((scope) => {
      if (typeof scope !== "string") {
        return `${scope.address}::${scope.module}::${scope.function}`;
      }
      if (scope.split("::").length !== 3)
        throw Error("invalid scope");
      return scope;
    });
    const allOx3 = "0x3::*::*";
    if (!parsedScopes.find((item) => item === allOx3 || item === REQUIRED_SCOPE)) {
      parsedScopes.push(REQUIRED_SCOPE);
    }
    return new Session(
      input.appName,
      input.appUrl,
      parsedScopes,
      input.signer.getRoochAddress(),
      input.signer.getBitcoinAddress(),
      input.keypair,
      input.maxInactiveInterval
    ).build(input.client, input.signer);
  }
  static fromJson(jsonObj) {
    const {
      appName,
      appUrl,
      scopes,
      secretKey,
      maxInactiveInterval,
      bitcoinAddress,
      roochAddress,
      localCreateSessionTime,
      lastActiveTime
    } = jsonObj;
    return new Session(
      appName,
      appUrl,
      scopes,
      new import_address.RoochAddress(roochAddress),
      new import_address.BitcoinAddress(bitcoinAddress),
      import_keypairs.Ed25519Keypair.fromSecretKey(secretKey),
      maxInactiveInterval,
      localCreateSessionTime,
      lastActiveTime
    );
  }
  sign(input) {
    this.lastActiveTime = Date.now();
    return this.keypair.sign(input);
  }
  signTransaction(input) {
    return import_crypto.Authenticator.rooch(input.hashData(), this);
  }
  getRoochAddress() {
    return this.roochAddress;
  }
  getBitcoinAddress() {
    return this.bitcoinAddress;
  }
  getKeyScheme() {
    return this.keypair.getKeyScheme();
  }
  getPublicKey() {
    return this.keypair.getPublicKey();
  }
  getCreateTime() {
    return this.localCreateSessionTime;
  }
  getAuthKey() {
    return this.keypair.getRoochAddress().toHexAddress();
  }
  async build(client, signer) {
    const [addrs, mods, fns] = this.scopes.map((scope) => {
      return scope.split("::");
    }).reduce(
      (acc, val) => {
        acc[0].push(val[0]);
        acc[1].push(val[1]);
        acc[2].push(val[2]);
        return acc;
      },
      [[], [], []]
    );
    const tx = new import_transactions.Transaction();
    tx.callFunction({
      target: "0x3::session_key::create_session_key_with_multi_scope_entry",
      args: [
        import_bcs.Args.string(this.appName),
        import_bcs.Args.string(this.appUrl),
        import_bcs.Args.vec("u8", Array.from((0, import_utils.fromHEX)(this.getAuthKey()))),
        import_bcs.Args.vec("address", addrs),
        import_bcs.Args.vec("string", mods),
        import_bcs.Args.vec("string", fns),
        import_bcs.Args.u64(BigInt(this.maxInactiveInterval))
      ],
      info: `Welcome to ${this.appName}
You will authorize session:
${"Scope:\n" + this.scopes.join("\n") + "\nTimeOut:" + this.maxInactiveInterval.toString()}`
    });
    const result = await client.signAndExecuteTransaction({
      transaction: tx,
      signer
    });
    if (result.execution_info.status.type === "executed") {
      return this;
    } else {
      throw Error(`create session failed ${result.execution_info.status}`);
    }
  }
  toJSON() {
    return {
      appName: this.appName,
      appUrl: this.appUrl,
      scopes: this.scopes,
      secretKey: this.keypair.getSecretKey(),
      maxInactiveInterval: this.maxInactiveInterval,
      bitcoinAddress: this.bitcoinAddress.toStr(),
      roochAddress: this.roochAddress.toStr(),
      localCreateSessionTime: this.localCreateSessionTime,
      lastActiveTime: this.lastActiveTime
    };
  }
}
//# sourceMappingURL=session.js.map
