import { bcs, BcsType } from "@mysten/bcs";
import { bytes, fromHEX, toHEX } from "../utils/index.js";
import {
  normalizeRoochAddress,
  ROOCH_ADDRESS_LENGTH,
  convertToRoochAddressBytes,
  isValidAddress
} from "../address/index.js";
import { Serializer } from "./serializer.js";
function enumKind(type) {
  return type.transform({
    input: ({ kind, ...val }) => ({
      [kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
const raw = (type, options) => {
  return new BcsType({
    name: `vector<${type.name}>`,
    read: (reader) => {
      const result = [];
      for (let i = 0; i < length; i++) {
        result[i] = type.read(reader);
      }
      return result;
    },
    write: (value, writer) => {
      for (const item of value) {
        type.write(item, writer);
      }
    },
    ...options,
    validate: (value) => {
      options?.validate?.(value);
      if (!("length" in value)) {
        throw new TypeError(`Expected array, found ${typeof value}`);
      }
    }
  });
};
const RawBytes = (coder = "hex") => {
  return raw(bcs.u8()).transform({
    input: (input) => typeof input === "string" ? bytes(coder, input) : input,
    output: (input) => input
  });
};
const Vector = (coder = "hex") => {
  return bcs.vector(bcs.u8()).transform({
    input: (input) => typeof input === "string" ? bytes(coder, input) : input,
    output: (input) => new Uint8Array(input)
  });
};
const Address = bcs.bytes(ROOCH_ADDRESS_LENGTH).transform({
  validate: (input) => {
    if (!isValidAddress(input)) {
      throw new Error(`Invalid address ${input}`);
    }
  },
  input: (input) => convertToRoochAddressBytes(input),
  output: (val) => normalizeRoochAddress(toHEX(val))
});
const MultiChainAddress = bcs.struct("MultiChainAddress", {
  multiChainId: bcs.u64().transform({
    input: (input) => typeof typeof input === "number" ? BigInt(input) : input,
    output: (input) => BigInt(input)
  }),
  rawAddress: bcs.vector(bcs.u8())
});
const ObjectId = bcs.vector(Address).transform({
  input: (input) => {
    if (typeof input === "string") {
      const normalizeId = normalizeRoochAddress(input);
      let bytes2 = fromHEX(normalizeId);
      let addresses = [];
      for (let i = 0; i < bytes2.length; i += ROOCH_ADDRESS_LENGTH) {
        let chunk = bytes2.slice(i, i + ROOCH_ADDRESS_LENGTH);
        if (chunk.length !== ROOCH_ADDRESS_LENGTH) {
          throw new Error("Invalid chunk size");
        }
        addresses.push(chunk);
      }
      return addresses;
    }
    return input;
  },
  output: (val) => {
    return val.join("");
  }
});
const InnerTypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => InnerTypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
const StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(InnerTypeTag)
});
const TypeTag = InnerTypeTag.transform({
  input: (typeTag) => typeof typeTag === "string" ? Serializer.typeTagParseFromStr(typeTag, true) : typeTag,
  output: (typeTag) => Serializer.tagToString(typeTag)
});
const BitcoinAuthPayload = bcs.struct("AuthPayload", {
  signature: Vector(),
  messagePrefix: Vector("utf8"),
  messageInfo: Vector("utf8"),
  publicKey: Vector("hex"),
  fromAddress: Vector("utf8")
});
const ModuleId = bcs.struct("ModuleId", {
  address: Address,
  name: bcs.string()
});
const FunctionId = bcs.struct("FunctionId", {
  moduleId: ModuleId,
  name: bcs.string()
});
const ScriptCall = bcs.struct("ScriptCall", {
  code: RawBytes(),
  args: bcs.vector(bcs.u8()),
  typeArgs: bcs.vector(TypeTag)
});
const CallFunction = bcs.struct("FunctionCall", {
  functionId: FunctionId,
  typeArgs: bcs.vector(TypeTag),
  args: bcs.vector(bcs.vector(bcs.u8()))
});
const MoveAction = enumKind(
  bcs.enum("MoveAction", {
    ScriptCall,
    CallFunction
  })
);
const RoochTransactionData = bcs.struct("RoochTransactionData", {
  sender: Address,
  sequenceNumber: bcs.u64(),
  chainId: bcs.u64(),
  maxGas: bcs.u64(),
  action: MoveAction
});
const Authenticator = bcs.struct("Authenticator", {
  authValidatorId: bcs.u64(),
  payload: bcs.vector(bcs.u8())
});
const RoochTransaction = bcs.struct("RoochTransaction", {
  data: raw(bcs.u8()),
  auth: raw(bcs.u8())
});
export {
  Address,
  Authenticator,
  BitcoinAuthPayload,
  CallFunction,
  FunctionId,
  ModuleId,
  MoveAction,
  MultiChainAddress,
  ObjectId,
  RawBytes,
  RoochTransaction,
  RoochTransactionData,
  ScriptCall,
  StructTag,
  TypeTag,
  Vector,
  raw
};
//# sourceMappingURL=bcs.js.map
