{
  "version": 3,
  "sources": ["../../../src/bcs/bcs.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs, BcsType, BcsTypeOptions } from '@mysten/bcs'\n\nimport { address, Bytes } from '../types/index.js'\nimport { bytes, CoderType, fromHEX, toHEX } from '../utils/index.js'\nimport {\n  normalizeRoochAddress,\n  ROOCH_ADDRESS_LENGTH,\n  convertToRoochAddressBytes,\n  isValidAddress,\n} from '../address/index.js'\n\nimport { Serializer } from './serializer.js'\nimport type { BcsTypeTag as TypeTagType } from './types.js'\n\ntype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never\ntype EnumKindTransform<T> = T extends infer U\n  ? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n  : never\n\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n  return type.transform({\n    input: ({ kind, ...val }: EnumKindTransform<Input>) =>\n      ({\n        [kind]: val,\n      }) as Input,\n    output: (val) => {\n      const key = Object.keys(val)[0] as keyof T\n\n      return { kind: key, ...val[key] } as EnumKindTransform<T>\n    },\n  })\n}\n\n// TODO: support parse\nexport const raw = <T, Input>(\n  type: BcsType<T, Input>,\n  options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n): BcsType<T[], Iterable<Input> & { length: number }> => {\n  return new BcsType<T[], Iterable<Input> & { length: number }>({\n    name: `vector<${type.name}>`,\n    read: (reader) => {\n      const result: T[] = []\n      for (let i = 0; i < length; i++) {\n        result[i] = type.read(reader)\n      }\n      return result\n    },\n    write: (value, writer) => {\n      for (const item of value) {\n        type.write(item, writer)\n      }\n    },\n    ...options,\n    validate: (value) => {\n      options?.validate?.(value)\n      if (!('length' in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`)\n      }\n    },\n  })\n}\n\nexport const RawBytes = (coder: CoderType = 'hex') => {\n  return raw(bcs.u8()).transform({\n    input: (input: string | Bytes) => (typeof input === 'string' ? bytes(coder, input) : input),\n    output: (input) => input,\n  })\n}\n\nexport const Vector = (coder: CoderType = 'hex') => {\n  return bcs.vector(bcs.u8()).transform({\n    input: (input: string | Bytes) => (typeof input === 'string' ? bytes(coder, input) : input),\n    output: (input) => new Uint8Array(input),\n  })\n}\n\nexport const Address = bcs.bytes(ROOCH_ADDRESS_LENGTH).transform({\n  validate: (input) => {\n    if (!isValidAddress(input)) {\n      throw new Error(`Invalid address ${input}`)\n    }\n  },\n  input: (input: address) => convertToRoochAddressBytes(input),\n\n  output: (val) => normalizeRoochAddress(toHEX(val)),\n})\n\nexport const MultiChainAddress = bcs.struct('MultiChainAddress', {\n  multiChainId: bcs.u64().transform({\n    input: (input: number | bigint) => (typeof typeof input === 'number' ? BigInt(input) : input),\n    output: (input) => BigInt(input),\n  }),\n  rawAddress: bcs.vector(bcs.u8()),\n})\n\nexport const ObjectId = bcs.vector(Address).transform({\n  input: (input: string | Bytes[]) => {\n    if (typeof input === 'string') {\n      const normalizeId = normalizeRoochAddress(input)\n      let bytes = fromHEX(normalizeId)\n      let addresses: Uint8Array[] = []\n      for (let i = 0; i < bytes.length; i += ROOCH_ADDRESS_LENGTH) {\n        let chunk = bytes.slice(i, i + ROOCH_ADDRESS_LENGTH)\n        if (chunk.length !== ROOCH_ADDRESS_LENGTH) {\n          throw new Error('Invalid chunk size')\n        }\n        addresses.push(chunk)\n      }\n      return addresses\n    }\n\n    return input\n  },\n  output: (val) => {\n    return val.join('')\n  },\n})\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => InnerTypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null,\n}) as BcsType<TypeTagType>\n\nexport const StructTag = bcs.struct('StructTag', {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(InnerTypeTag),\n})\n\nexport const TypeTag = InnerTypeTag.transform({\n  input: (typeTag: string | TypeTagType) =>\n    typeof typeTag === 'string' ? Serializer.typeTagParseFromStr(typeTag, true) : typeTag,\n  output: (typeTag: TypeTagType) => Serializer.tagToString(typeTag),\n})\n\nexport const BitcoinAuthPayload = bcs.struct('AuthPayload', {\n  signature: Vector(),\n  messagePrefix: Vector('utf8'),\n  messageInfo: Vector('utf8'),\n  publicKey: Vector('hex'),\n  fromAddress: Vector('utf8'),\n})\n\nexport const ModuleId = bcs.struct('ModuleId', {\n  address: Address,\n  name: bcs.string(),\n})\n\nexport const FunctionId = bcs.struct('FunctionId', {\n  moduleId: ModuleId,\n  name: bcs.string(),\n})\n\nexport const ScriptCall = bcs.struct('ScriptCall', {\n  code: RawBytes(),\n  args: bcs.vector(bcs.u8()),\n  typeArgs: bcs.vector(TypeTag),\n})\n\nexport const CallFunction = bcs.struct('FunctionCall', {\n  functionId: FunctionId,\n  typeArgs: bcs.vector(TypeTag),\n  args: bcs.vector(bcs.vector(bcs.u8())),\n})\n\nexport const MoveAction = enumKind(\n  bcs.enum('MoveAction', {\n    ScriptCall,\n    CallFunction,\n  }),\n)\n\nexport const RoochTransactionData = bcs.struct('RoochTransactionData', {\n  sender: Address,\n  sequenceNumber: bcs.u64(),\n  chainId: bcs.u64(),\n  maxGas: bcs.u64(),\n  action: MoveAction,\n})\n\nexport const Authenticator = bcs.struct('Authenticator', {\n  authValidatorId: bcs.u64(),\n  payload: bcs.vector(bcs.u8()),\n})\n\nexport const RoochTransaction = bcs.struct('RoochTransaction', {\n  data: raw(bcs.u8()),\n  auth: raw(bcs.u8()),\n})\n"],
  "mappings": "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",
  "names": ["bytes"]
}
