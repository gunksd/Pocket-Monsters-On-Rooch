import { BcsType, BcsTypeOptions } from '@mysten/bcs';
import { address } from '../types/index.js';
import { CoderType } from '../utils/index.js';
import type { BcsTypeTag as TypeTagType } from './types.js';
export declare const raw: <T, Input>(type: BcsType<T, Input>, options?: BcsTypeOptions<T[], Iterable<Input> & {
    length: number;
}>) => BcsType<T[], Iterable<Input> & {
    length: number;
}>;
export declare const RawBytes: (coder?: CoderType) => BcsType<number[], string | Uint8Array>;
export declare const Vector: (coder?: CoderType) => BcsType<Uint8Array, string | Uint8Array>;
export declare const Address: BcsType<string, address>;
export declare const MultiChainAddress: BcsType<{
    multiChainId: bigint;
    rawAddress: number[];
}, {
    multiChainId: number | bigint;
    rawAddress: Iterable<number> & {
        length: number;
    };
}>;
export declare const ObjectId: BcsType<string, string | Uint8Array[]>;
export declare const StructTag: BcsType<{
    address: string;
    module: string;
    name: string;
    typeParams: TypeTagType[];
}, {
    address: address;
    module: string;
    name: string;
    typeParams: Iterable<TypeTagType> & {
        length: number;
    };
}>;
export declare const TypeTag: BcsType<string, string | TypeTagType>;
export declare const BitcoinAuthPayload: BcsType<{
    signature: Uint8Array;
    messagePrefix: Uint8Array;
    messageInfo: Uint8Array;
    publicKey: Uint8Array;
    fromAddress: Uint8Array;
}, {
    signature: string | Uint8Array;
    messagePrefix: string | Uint8Array;
    messageInfo: string | Uint8Array;
    publicKey: string | Uint8Array;
    fromAddress: string | Uint8Array;
}>;
export declare const ModuleId: BcsType<{
    address: string;
    name: string;
}, {
    address: address;
    name: string;
}>;
export declare const FunctionId: BcsType<{
    moduleId: {
        address: string;
        name: string;
    };
    name: string;
}, {
    moduleId: {
        address: address;
        name: string;
    };
    name: string;
}>;
export declare const ScriptCall: BcsType<{
    code: number[];
    args: number[];
    typeArgs: string[];
}, {
    code: string | Uint8Array;
    args: Iterable<number> & {
        length: number;
    };
    typeArgs: Iterable<string | TypeTagType> & {
        length: number;
    };
}>;
export declare const CallFunction: BcsType<{
    functionId: {
        moduleId: {
            address: string;
            name: string;
        };
        name: string;
    };
    typeArgs: string[];
    args: number[][];
}, {
    functionId: {
        moduleId: {
            address: address;
            name: string;
        };
        name: string;
    };
    typeArgs: Iterable<string | TypeTagType> & {
        length: number;
    };
    args: Iterable<Iterable<number> & {
        length: number;
    }> & {
        length: number;
    };
}>;
export declare const MoveAction: BcsType<{
    readonly [x: number]: string;
    toString: () => string;
    charAt: (pos: number) => string;
    charCodeAt: (index: number) => number;
    concat: (...strings: string[]) => string;
    indexOf: (searchString: string, position?: number | undefined) => number;
    lastIndexOf: (searchString: string, position?: number | undefined) => number;
    localeCompare: {
        (that: string): number;
        (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
        (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
    };
    match: {
        (regexp: string | RegExp): RegExpMatchArray | null;
        (matcher: {
            [Symbol.match](string: string): RegExpMatchArray | null;
        }): RegExpMatchArray | null;
    };
    replace: {
        (searchValue: string | RegExp, replaceValue: string): string;
        (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        (searchValue: {
            [Symbol.replace](string: string, replaceValue: string): string;
        }, replaceValue: string): string;
        (searchValue: {
            [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
        }, replacer: (substring: string, ...args: any[]) => string): string;
    };
    search: {
        (regexp: string | RegExp): number;
        (searcher: {
            [Symbol.search](string: string): number;
        }): number;
    };
    slice: (start?: number | undefined, end?: number | undefined) => string;
    split: {
        (separator: string | RegExp, limit?: number | undefined): string[];
        (splitter: {
            [Symbol.split](string: string, limit?: number | undefined): string[];
        }, limit?: number | undefined): string[];
    };
    substring: (start: number, end?: number | undefined) => string;
    toLowerCase: () => string;
    toLocaleLowerCase: {
        (locales?: string | string[] | undefined): string;
        (locales?: Intl.LocalesArgument): string;
    };
    toUpperCase: () => string;
    toLocaleUpperCase: {
        (locales?: string | string[] | undefined): string;
        (locales?: Intl.LocalesArgument): string;
    };
    trim: () => string;
    readonly length: number;
    substr: (from: number, length?: number | undefined) => string;
    valueOf: () => string;
    codePointAt: (pos: number) => number | undefined;
    includes: (searchString: string, position?: number | undefined) => boolean;
    endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
    normalize: {
        (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
        (form?: string | undefined): string;
    };
    repeat: (count: number) => string;
    startsWith: (searchString: string, position?: number | undefined) => boolean;
    anchor: (name: string) => string;
    big: () => string;
    blink: () => string;
    bold: () => string;
    fixed: () => string;
    fontcolor: (color: string) => string;
    fontsize: {
        (size: number): string;
        (size: string): string;
    };
    italics: () => string;
    link: (url: string) => string;
    small: () => string;
    strike: () => string;
    sub: () => string;
    sup: () => string;
    padStart: (maxLength: number, fillString?: string | undefined) => string;
    padEnd: (maxLength: number, fillString?: string | undefined) => string;
    trimEnd: () => string;
    trimStart: () => string;
    trimLeft: () => string;
    trimRight: () => string;
    matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
    replaceAll: {
        (searchValue: string | RegExp, replaceValue: string): string;
        (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
    };
    at: (index: number) => string | undefined;
    [Symbol.iterator]: () => IterableIterator<string>;
    kind: "$kind" | "ScriptCall" | "CallFunction";
} | {
    code: number[];
    args: number[];
    typeArgs: string[];
    kind: "$kind" | "ScriptCall" | "CallFunction";
} | {
    functionId: {
        moduleId: {
            address: string;
            name: string;
        };
        name: string;
    };
    typeArgs: string[];
    args: number[][];
    kind: "$kind" | "ScriptCall" | "CallFunction";
} | {
    readonly [x: number]: string;
    toString: () => string;
    charAt: (pos: number) => string;
    charCodeAt: (index: number) => number;
    concat: (...strings: string[]) => string;
    indexOf: (searchString: string, position?: number | undefined) => number;
    lastIndexOf: (searchString: string, position?: number | undefined) => number;
    localeCompare: {
        (that: string): number;
        (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
        (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
    };
    match: {
        (regexp: string | RegExp): RegExpMatchArray | null;
        (matcher: {
            [Symbol.match](string: string): RegExpMatchArray | null;
        }): RegExpMatchArray | null;
    };
    replace: {
        (searchValue: string | RegExp, replaceValue: string): string;
        (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        (searchValue: {
            [Symbol.replace](string: string, replaceValue: string): string;
        }, replaceValue: string): string;
        (searchValue: {
            [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
        }, replacer: (substring: string, ...args: any[]) => string): string;
    };
    search: {
        (regexp: string | RegExp): number;
        (searcher: {
            [Symbol.search](string: string): number;
        }): number;
    };
    slice: (start?: number | undefined, end?: number | undefined) => string;
    split: {
        (separator: string | RegExp, limit?: number | undefined): string[];
        (splitter: {
            [Symbol.split](string: string, limit?: number | undefined): string[];
        }, limit?: number | undefined): string[];
    };
    substring: (start: number, end?: number | undefined) => string;
    toLowerCase: () => string;
    toLocaleLowerCase: {
        (locales?: string | string[] | undefined): string;
        (locales?: Intl.LocalesArgument): string;
    };
    toUpperCase: () => string;
    toLocaleUpperCase: {
        (locales?: string | string[] | undefined): string;
        (locales?: Intl.LocalesArgument): string;
    };
    trim: () => string;
    readonly length: number;
    substr: (from: number, length?: number | undefined) => string;
    valueOf: () => string;
    codePointAt: (pos: number) => number | undefined;
    includes: (searchString: string, position?: number | undefined) => boolean;
    endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
    normalize: {
        (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
        (form?: string | undefined): string;
    };
    repeat: (count: number) => string;
    startsWith: (searchString: string, position?: number | undefined) => boolean;
    anchor: (name: string) => string;
    big: () => string;
    blink: () => string;
    bold: () => string;
    fixed: () => string;
    fontcolor: (color: string) => string;
    fontsize: {
        (size: number): string;
        (size: string): string;
    };
    italics: () => string;
    link: (url: string) => string;
    small: () => string;
    strike: () => string;
    sub: () => string;
    sup: () => string;
    padStart: (maxLength: number, fillString?: string | undefined) => string;
    padEnd: (maxLength: number, fillString?: string | undefined) => string;
    trimEnd: () => string;
    trimStart: () => string;
    trimLeft: () => string;
    trimRight: () => string;
    matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
    replaceAll: {
        (searchValue: string | RegExp, replaceValue: string): string;
        (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
    };
    at: (index: number) => string | undefined;
    [Symbol.iterator]: () => IterableIterator<string>;
    kind: "$kind" | "ScriptCall" | "CallFunction";
}, {
    code: string | Uint8Array;
    args: Iterable<number> & {
        length: number;
    };
    typeArgs: Iterable<string | TypeTagType> & {
        length: number;
    };
    kind: "ScriptCall";
} | {
    functionId: {
        moduleId: {
            address: address;
            name: string;
        };
        name: string;
    };
    typeArgs: Iterable<string | TypeTagType> & {
        length: number;
    };
    args: Iterable<Iterable<number> & {
        length: number;
    }> & {
        length: number;
    };
    kind: "CallFunction";
}>;
export declare const RoochTransactionData: BcsType<{
    sender: string;
    sequenceNumber: string;
    chainId: string;
    maxGas: string;
    action: {
        readonly [x: number]: string;
        toString: () => string;
        charAt: (pos: number) => string;
        charCodeAt: (index: number) => number;
        concat: (...strings: string[]) => string;
        indexOf: (searchString: string, position?: number | undefined) => number;
        lastIndexOf: (searchString: string, position?: number | undefined) => number;
        localeCompare: {
            (that: string): number;
            (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
            (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
        };
        match: {
            (regexp: string | RegExp): RegExpMatchArray | null;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray | null;
            }): RegExpMatchArray | null;
        };
        replace: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice: (start?: number | undefined, end?: number | undefined) => string;
        split: {
            (separator: string | RegExp, limit?: number | undefined): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number | undefined): string[];
            }, limit?: number | undefined): string[];
        };
        substring: (start: number, end?: number | undefined) => string;
        toLowerCase: () => string;
        toLocaleLowerCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        toUpperCase: () => string;
        toLocaleUpperCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        trim: () => string;
        readonly length: number;
        substr: (from: number, length?: number | undefined) => string;
        valueOf: () => string;
        codePointAt: (pos: number) => number | undefined;
        includes: (searchString: string, position?: number | undefined) => boolean;
        endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
        normalize: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string | undefined): string;
        };
        repeat: (count: number) => string;
        startsWith: (searchString: string, position?: number | undefined) => boolean;
        anchor: (name: string) => string;
        big: () => string;
        blink: () => string;
        bold: () => string;
        fixed: () => string;
        fontcolor: (color: string) => string;
        fontsize: {
            (size: number): string;
            (size: string): string;
        };
        italics: () => string;
        link: (url: string) => string;
        small: () => string;
        strike: () => string;
        sub: () => string;
        sup: () => string;
        padStart: (maxLength: number, fillString?: string | undefined) => string;
        padEnd: (maxLength: number, fillString?: string | undefined) => string;
        trimEnd: () => string;
        trimStart: () => string;
        trimLeft: () => string;
        trimRight: () => string;
        matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
        replaceAll: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        };
        at: (index: number) => string | undefined;
        [Symbol.iterator]: () => IterableIterator<string>;
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        code: number[];
        args: number[];
        typeArgs: string[];
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        functionId: {
            moduleId: {
                address: string;
                name: string;
            };
            name: string;
        };
        typeArgs: string[];
        args: number[][];
        kind: "$kind" | "ScriptCall" | "CallFunction";
    } | {
        readonly [x: number]: string;
        toString: () => string;
        charAt: (pos: number) => string;
        charCodeAt: (index: number) => number;
        concat: (...strings: string[]) => string;
        indexOf: (searchString: string, position?: number | undefined) => number;
        lastIndexOf: (searchString: string, position?: number | undefined) => number;
        localeCompare: {
            (that: string): number;
            (that: string, locales?: string | string[] | undefined, options?: Intl.CollatorOptions | undefined): number;
            (that: string, locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions | undefined): number;
        };
        match: {
            (regexp: string | RegExp): RegExpMatchArray | null;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray | null;
            }): RegExpMatchArray | null;
        };
        replace: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice: (start?: number | undefined, end?: number | undefined) => string;
        split: {
            (separator: string | RegExp, limit?: number | undefined): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number | undefined): string[];
            }, limit?: number | undefined): string[];
        };
        substring: (start: number, end?: number | undefined) => string;
        toLowerCase: () => string;
        toLocaleLowerCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        toUpperCase: () => string;
        toLocaleUpperCase: {
            (locales?: string | string[] | undefined): string;
            (locales?: Intl.LocalesArgument): string;
        };
        trim: () => string;
        readonly length: number;
        substr: (from: number, length?: number | undefined) => string;
        valueOf: () => string;
        codePointAt: (pos: number) => number | undefined;
        includes: (searchString: string, position?: number | undefined) => boolean;
        endsWith: (searchString: string, endPosition?: number | undefined) => boolean;
        normalize: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string | undefined): string;
        };
        repeat: (count: number) => string;
        startsWith: (searchString: string, position?: number | undefined) => boolean;
        anchor: (name: string) => string;
        big: () => string;
        blink: () => string;
        bold: () => string;
        fixed: () => string;
        fontcolor: (color: string) => string;
        fontsize: {
            (size: number): string;
            (size: string): string;
        };
        italics: () => string;
        link: (url: string) => string;
        small: () => string;
        strike: () => string;
        sub: () => string;
        sup: () => string;
        padStart: (maxLength: number, fillString?: string | undefined) => string;
        padEnd: (maxLength: number, fillString?: string | undefined) => string;
        trimEnd: () => string;
        trimStart: () => string;
        trimLeft: () => string;
        trimRight: () => string;
        matchAll: (regexp: RegExp) => IterableIterator<RegExpExecArray>;
        replaceAll: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        };
        at: (index: number) => string | undefined;
        [Symbol.iterator]: () => IterableIterator<string>;
        kind: "$kind" | "ScriptCall" | "CallFunction";
    };
}, {
    sender: address;
    sequenceNumber: string | number | bigint;
    chainId: string | number | bigint;
    maxGas: string | number | bigint;
    action: {
        code: string | Uint8Array;
        args: Iterable<number> & {
            length: number;
        };
        typeArgs: Iterable<string | TypeTagType> & {
            length: number;
        };
        kind: "ScriptCall";
    } | {
        functionId: {
            moduleId: {
                address: address;
                name: string;
            };
            name: string;
        };
        typeArgs: Iterable<string | TypeTagType> & {
            length: number;
        };
        args: Iterable<Iterable<number> & {
            length: number;
        }> & {
            length: number;
        };
        kind: "CallFunction";
    };
}>;
export declare const Authenticator: BcsType<{
    authValidatorId: string;
    payload: number[];
}, {
    authValidatorId: string | number | bigint;
    payload: Iterable<number> & {
        length: number;
    };
}>;
export declare const RoochTransaction: BcsType<{
    data: number[];
    auth: number[];
}, {
    data: Iterable<number> & {
        length: number;
    };
    auth: Iterable<number> & {
        length: number;
    };
}>;
