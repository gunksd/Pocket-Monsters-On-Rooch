import { bech32m } from "@scure/base";
import { isBytes, str } from "../utils/bytes.js";
import { fromHEX, getHexByteLength, isHex } from "../utils/hex.js";
import { BitcoinAddress } from "./bitcoin.js";
import { ROOCH_ADDRESS_LENGTH, ROOCH_BECH32_PREFIX } from "./address.js";
function decodeToRoochAddressStr(input) {
  if (typeof input === "string") {
    if (isValidRoochAddress(input)) {
      return input;
    }
    if (isValidBitcoinAddress(input)) {
      return new BitcoinAddress(input).genRoochAddress().toHexAddress();
    }
    throw Error("Invalid Address");
  }
  if (isBytes(input)) {
    return str("hex", input);
  }
  return decodeToRoochAddressStr(input.toStr());
}
function convertToRoochAddressBytes(input) {
  if (typeof input === "string") {
    const normalizeAddress = normalizeRoochAddress(input);
    if (isHex(normalizeAddress) && getHexByteLength(normalizeAddress) === ROOCH_ADDRESS_LENGTH) {
      return fromHEX(normalizeAddress);
    }
    if (input.startsWith(ROOCH_BECH32_PREFIX)) {
      const decode = bech32m.decode(input);
      const bytes = bech32m.fromWords(decode.words);
      if (decode.prefix === ROOCH_BECH32_PREFIX && bytes.length === ROOCH_ADDRESS_LENGTH) {
        return bytes;
      }
    }
    return new BitcoinAddress(input).genRoochAddress().toBytes();
  }
  return isBytes(input) ? input : convertToRoochAddressBytes(input.toStr());
}
function isValidBitcoinAddress(input) {
  try {
    new BitcoinAddress(input);
    return true;
  } catch (_) {
  }
  return false;
}
function isValidRoochAddress(input) {
  if (typeof input === "string") {
    const normalizeAddress = normalizeRoochAddress(input);
    if (isHex(normalizeAddress) && getHexByteLength(normalizeAddress) === ROOCH_ADDRESS_LENGTH) {
      return true;
    }
    if (input.startsWith(ROOCH_BECH32_PREFIX)) {
      const decode = bech32m.decode(input);
      const bytes = bech32m.fromWords(decode.words);
      return decode.prefix === ROOCH_BECH32_PREFIX && bytes.length === ROOCH_ADDRESS_LENGTH;
    }
    return false;
  }
  return isBytes(input) ? input.length === ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr());
}
function isValidAddress(input) {
  if (typeof input === "string") {
    if (isValidRoochAddress(input)) {
      return true;
    }
    return isValidBitcoinAddress(input);
  }
  return isBytes(input) ? input.length === ROOCH_ADDRESS_LENGTH : isValidAddress(input.toStr());
}
function normalizeRoochAddress(input, forceAdd0x = false) {
  let address2 = input.toLowerCase();
  if (!forceAdd0x && address2.startsWith("0x")) {
    address2 = address2.slice(2);
  }
  return `0x${address2.padStart(ROOCH_ADDRESS_LENGTH * 2, "0")}`;
}
function canonicalRoochAddress(input, forceAdd0x = false) {
  return normalizeRoochAddress(input, forceAdd0x).slice(2);
}
export {
  canonicalRoochAddress,
  convertToRoochAddressBytes,
  decodeToRoochAddressStr,
  isValidAddress,
  isValidBitcoinAddress,
  isValidRoochAddress,
  normalizeRoochAddress
};
//# sourceMappingURL=util.js.map
