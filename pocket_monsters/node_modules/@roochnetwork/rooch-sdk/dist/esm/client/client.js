import { Args } from "../bcs/index.js";
import { Session } from "../session/index.js";
import {
  isValidRoochAddress,
  decodeToRoochAddressStr,
  BitcoinAddress
} from "../address/index.js";
import { fromHEX, str } from "../utils/index.js";
import { RoochHTTPTransport } from "./httpTransport.js";
import {
  CallFunction,
  Transaction,
  normalizeTypeArgsToStr
} from "../transactions/index.js";
const ROOCH_CLIENT_BRAND = Symbol.for("@roochnetwork/RoochClient");
function isRoochClient(client) {
  return typeof client === "object" && client !== null && client[ROOCH_CLIENT_BRAND] === true;
}
class RoochClient {
  get [ROOCH_CLIENT_BRAND]() {
    return true;
  }
  /**
   * Establish a connection to a rooch RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(options) {
    this.transport = options.transport ?? new RoochHTTPTransport({ url: options.url });
  }
  async getRpcApiVersion() {
    const resp = await this.transport.request({
      method: "rpc.discover",
      params: []
    });
    return resp.info.version;
  }
  async getChainId() {
    if (this.chainID) {
      return this.chainID;
    }
    return this.transport.request({
      method: "rooch_getChainID",
      params: []
    });
  }
  async executeViewFunction(input) {
    const callFunction = new CallFunction(input);
    return await this.transport.request({
      method: "rooch_executeViewFunction",
      params: [
        {
          function_id: callFunction.functionId(),
          args: callFunction.encodeArgs(),
          ty_args: callFunction.typeArgs
        }
      ]
    });
  }
  async signAndExecuteTransaction({
    transaction,
    signer,
    option = { withOutput: true }
  }) {
    let transactionHex;
    if (transaction instanceof Uint8Array) {
      transactionHex = str("hex", transaction);
    } else {
      let sender = signer.getRoochAddress().toHexAddress();
      transaction.setChainId(await this.getChainId());
      transaction.setSeqNumber(await this.getSequenceNumber(sender));
      transaction.setSender(sender);
      const auth = await signer.signTransaction(transaction);
      transaction.setAuth(auth);
      transactionHex = `0x${transaction.encode().toHex()}`;
    }
    return await this.transport.request({
      method: "rooch_executeRawTransaction",
      params: [transactionHex, option]
    });
  }
  // Get the states by access_path
  async getStates(params) {
    const result = await this.transport.request({
      method: "rooch_getStates",
      params: [params.accessPath, params.stateOption]
    });
    const typedResult = result;
    return typedResult[0] === null ? [] : typedResult;
  }
  async listStates(params) {
    return await this.transport.request({
      method: "rooch_listStates",
      params: [params.accessPath, params.cursor, params.limit, params.stateOption]
    });
  }
  async getModuleAbi(params) {
    return await this.transport.request({
      method: "rooch_getModuleABI",
      params: [params.moduleAddr, params.moduleName]
    });
  }
  async getEvents(input) {
    return await this.transport.request({
      method: "rooch_getEventsByEventHandle",
      params: [
        input.eventHandleType,
        input.cursor,
        input.limit,
        input.descendingOrder,
        input.eventOptions
      ]
    });
  }
  async queryEvents(input) {
    return await this.transport.request({
      method: "rooch_queryEvents",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  // Query the Inscription via global index by Inscription filter
  async queryInscriptions(input) {
    return await this.transport.request({
      method: "btc_queryInscriptions",
      params: [input.filter, input.cursor, input.limit, input.descendingOrder]
    });
  }
  async queryUTXO(input) {
    return this.transport.request({
      method: "btc_queryUTXOs",
      params: [input.filter, input.cursor, input.limit, input.descendingOrder]
    });
  }
  async queryObjectStates(input) {
    return this.transport.request({
      method: "rooch_queryObjectStates",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  async queryTransactions(input) {
    return this.transport.request({
      method: "rooch_queryTransactions",
      params: [input.filter, input.cursor, input.limit, input.queryOption]
    });
  }
  // helper fn
  async getSequenceNumber(address2) {
    const resp = await this.executeViewFunction({
      target: "0x2::account::sequence_number",
      args: [Args.address(address2)]
    });
    if (resp && resp.return_values) {
      return BigInt(resp.return_values[0].decoded_value);
    }
    return BigInt(0);
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidRoochAddress(input.owner)) {
      throw new Error("Invalid rooch address");
    }
    return await this.transport.request({
      method: "rooch_getBalance",
      params: [input.owner, input.coinType]
    });
  }
  async getBalances(input) {
    if (!input.owner || !isValidRoochAddress(input.owner)) {
      throw new Error("Invalid rooch address");
    }
    return await this.transport.request({
      method: "rooch_getBalances",
      params: [input.owner, input.cursor, input.limit]
    });
  }
  async transfer(input) {
    const tx = new Transaction();
    tx.callFunction({
      target: "0x3::transfer::transfer_coin",
      args: [Args.address(input.recipient), Args.u256(BigInt(input.amount))],
      typeArgs: [normalizeTypeArgsToStr(input.coinType)]
    });
    return await this.signAndExecuteTransaction({
      transaction: tx,
      signer: input.signer
    });
  }
  async transferObject(input) {
    const tx = new Transaction();
    tx.callFunction({
      target: "0x3::transfer::transfer_object",
      args: [Args.address(input.recipient), Args.objectId(input.objectId)],
      typeArgs: [normalizeTypeArgsToStr(input.objectType)]
    });
    return await this.signAndExecuteTransaction({
      transaction: tx,
      signer: input.signer
    });
  }
  async resolveBTCAddress(input) {
    const result = await this.executeViewFunction({
      target: "0x3::address_mapping::resolve_bitcoin",
      args: [Args.address(input.roochAddress)]
    });
    if (result.vm_status === "Executed" && result.return_values) {
      const value = result.return_values[0].decoded_value.value;
      const address2 = value.vec[0].value.bytes;
      return new BitcoinAddress(address2, input.network);
    }
    return void 0;
  }
  async createSession({ sessionArgs, signer }) {
    return Session.CREATE({
      ...sessionArgs,
      client: this,
      signer
    });
  }
  async removeSession({ authKey, signer }) {
    const tx = new Transaction();
    tx.callFunction({
      target: "0x3::session_key::remove_session_key_entry",
      args: [Args.vec("u8", Array.from(fromHEX(authKey)))]
    });
    return (await this.signAndExecuteTransaction({
      transaction: tx,
      signer
    })).execution_info.status.type === "executed";
  }
  async sessionIsExpired({
    address: address2,
    authKey
  }) {
    const result = await this.executeViewFunction({
      target: "0x3::session_key::is_expired_session_key",
      args: [Args.address(address2), Args.vec("u8", Array.from(fromHEX(authKey)))]
    });
    if (result.vm_status !== "Executed") {
      throw new Error("view 0x3::session_key::is_expired_session_key fail");
    }
    return result.return_values[0].decoded_value;
  }
  async getSessionKeys({
    address: address2,
    limit,
    cursor
  }) {
    const accessPath = `/resource/${decodeToRoochAddressStr(address2)}/0x3::session_key::SessionKeys`;
    const states = await this.getStates({
      accessPath,
      stateOption: {
        decode: true,
        showDisplay: true
      }
    });
    if (states.length === 0) {
      return {
        data: [],
        hasNextPage: false
      };
    }
    const tableId = states[0].decoded_value.value["value"].value["keys"].value["handle"].value["id"];
    const tablePath = `/table/${tableId}`;
    const statePage = await this.listStates({
      accessPath: tablePath,
      cursor,
      limit: limit?.toString(),
      stateOption: {
        decode: true,
        showDisplay: true
      }
    });
    const parseScopes = (data) => {
      const result = new Array();
      for (const scope of data) {
        const value = scope.value;
        result.push(`${value.module_address}::${value.module_name}::${value.function_name}`);
      }
      return result;
    };
    const parseStateToSessionInfo = () => {
      const result = new Array();
      for (const state of statePage.data) {
        const moveValue = state?.state.decoded_value;
        if (moveValue) {
          const val = moveValue.value.value.value;
          result.push({
            appName: val.app_name,
            appUrl: val.app_url,
            authenticationKey: val.authentication_key,
            scopes: parseScopes(val.scopes),
            createTime: parseInt(val.create_time),
            lastActiveTime: parseInt(val.last_active_time),
            maxInactiveInterval: parseInt(val.max_inactive_interval)
          });
        }
      }
      return result.sort((a, b) => b.createTime - a.createTime);
    };
    return {
      data: parseStateToSessionInfo(),
      cursor: statePage.next_cursor,
      hasNextPage: statePage.has_next_page
    };
  }
}
export {
  RoochClient,
  isRoochClient
};
//# sourceMappingURL=client.js.map
