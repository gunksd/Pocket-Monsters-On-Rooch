{
  "version": 3,
  "sources": ["../../../../src/keypairs/secp256k1/keypair.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HDKey } from '@scure/bip32'\n\nimport { schnorr, secp256k1 } from '@noble/curves/secp256k1'\nimport { BitcoinAddress, RoochAddress } from '../../address/index.js'\nimport {\n  Authenticator,\n  BitcoinSignMessage,\n  encodeRoochSercetKey,\n  isValidBIP32Path,\n  Keypair,\n  mnemonicToSeed,\n  decodeRoochSercetKey,\n  SignatureScheme,\n} from '../../crypto/index.js'\nimport { Bytes } from '../../types/index.js'\nimport { blake2b, sha256, toHEX } from '../../utils/index.js'\nimport { Secp256k1PublicKey } from './publickey.js'\nimport { Transaction } from '../../transactions/index.js'\n\nexport const DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\"\n\n/**\n * Secp256k1 Keypair data\n */\nexport interface Secp256k1KeypairData {\n  publicKey: Bytes\n  secretKey: Bytes\n}\n\n/**\n * An Secp256k1 Keypair used for signing transactions.\n */\nexport class Secp256k1Keypair extends Keypair {\n  private keypair: Secp256k1KeypairData\n\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n   *\n   * @param keypair secp256k1 keypair\n   */\n  constructor(keypair?: Secp256k1KeypairData) {\n    super()\n    if (keypair) {\n      this.keypair = keypair\n    } else {\n      const secretKey: Uint8Array = secp256k1.utils.randomPrivateKey()\n      const publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true)\n\n      this.keypair = { publicKey, secretKey }\n    }\n  }\n\n  getBitcoinAddress(): BitcoinAddress {\n    return this.getSchnorrPublicKey().toAddress()\n  }\n\n  getRoochAddress(): RoochAddress {\n    return this.getSchnorrPublicKey().toAddress().genRoochAddress()\n  }\n\n  /**\n   * Get the key scheme of the keypair Secp256k1\n   */\n  getKeyScheme(): SignatureScheme {\n    return 'Secp256k1'\n  }\n\n  /**\n   * Generate a new random keypair\n   */\n  static generate(): Secp256k1Keypair {\n    return new Secp256k1Keypair()\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param skipValidation skip secret key validation\n   */\n\n  static fromSecretKey(secretKey: Uint8Array | string, skipValidation?: boolean): Secp256k1Keypair {\n    const decodeSecretKey =\n      typeof secretKey === 'string'\n        ? (() => {\n            const decoded = decodeRoochSercetKey(secretKey)\n            if (decoded.schema !== 'Secp256k1') {\n              throw new Error('provided secretKey is invalid')\n            }\n            return decoded.secretKey\n          })()\n        : secretKey\n\n    const publicKey: Uint8Array = secp256k1.getPublicKey(decodeSecretKey, true)\n    if (!skipValidation) {\n      const encoder = new TextEncoder()\n      const signData = encoder.encode('rooch validation')\n      const msgHash = toHEX(blake2b(signData, { dkLen: 32 }))\n      const signature = secp256k1.sign(msgHash, decodeSecretKey)\n      if (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true })) {\n        throw new Error('Provided secretKey is invalid')\n      }\n    }\n    return new Secp256k1Keypair({ publicKey, secretKey: decodeSecretKey })\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed: Uint8Array): Secp256k1Keypair {\n    let publicKey = secp256k1.getPublicKey(seed, true)\n    return new Secp256k1Keypair({ publicKey, secretKey: seed })\n  }\n\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey(): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(this.keypair.publicKey)\n  }\n\n  getSchnorrPublicKey(): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(schnorr.getPublicKey(this.keypair.secretKey))\n  }\n\n  /**\n   * The Bech32 secret key string for this Secp256k1 keypair\n   */\n  getSecretKey(): string {\n    return encodeRoochSercetKey(this.keypair.secretKey, this.getKeyScheme())\n  }\n\n  /**\n   * Return the signature for the provided data.\n   */\n  async sign(input: Bytes) {\n    const msgHash = sha256(input)\n    const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true,\n    })\n\n    return sig.toCompactRawBytes()\n  }\n\n  async signTransaction(input: Transaction): Promise<Authenticator> {\n    return await Authenticator.bitcoin(\n      new BitcoinSignMessage(input.hashData(), input.getInfo() ?? 'sdk'),\n      this,\n    )\n  }\n\n  /**\n   * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics: string, path?: string): Secp256k1Keypair {\n    if (path == null) {\n      path = DEFAULT_SECP256K1_DERIVATION_PATH\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error('Invalid derivation path')\n    }\n    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path)\n    if (key.publicKey == null || key.privateKey == null) {\n      throw new Error('Invalid key')\n    }\n    return new Secp256k1Keypair({\n      publicKey: key.publicKey,\n      secretKey: key.privateKey,\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
