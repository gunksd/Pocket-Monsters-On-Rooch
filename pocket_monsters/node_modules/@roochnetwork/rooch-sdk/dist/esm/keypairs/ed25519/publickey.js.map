{
  "version": 3,
  "sources": ["../../../../src/keypairs/ed25519/publickey.ts"],
  "sourcesContent": ["// Copyright (c) RoochNetwork\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl'\n\nimport { ROOCH_ADDRESS_LENGTH, RoochAddress } from '../../address/index.js'\nimport type { PublicKeyInitData } from '../../crypto/index.js'\nimport { PublicKey, SIGNATURE_SCHEME_TO_FLAG } from '../../crypto/index.js'\nimport { blake2b, fromB64 } from '../../utils/index.js'\n\nconst PUBLIC_KEY_SIZE = 32\n\n/**\n * An Ed25519 public key\n */\nexport class Ed25519PublicKey extends PublicKey<RoochAddress> {\n  static SIZE = PUBLIC_KEY_SIZE\n\n  private readonly data: Uint8Array\n\n  /**\n   * Create a new Ed25519PublicKey object\n   * @param value ed25519 public key as buffer or base-64 encoded string\n   */\n  constructor(value: PublicKeyInitData) {\n    super()\n\n    if (typeof value === 'string') {\n      this.data = fromB64(value)\n    } else if (value instanceof Uint8Array) {\n      this.data = value\n    } else {\n      this.data = Uint8Array.from(value)\n    }\n\n    if (this.data.length !== PUBLIC_KEY_SIZE) {\n      throw new Error(\n        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n      )\n    }\n  }\n\n  /**\n   * Checks if two Ed25519 public keys are equal\n   */\n  override equals(publicKey: Ed25519PublicKey): boolean {\n    return super.equals(publicKey)\n  }\n\n  /**\n   * Return the byte array representation of the Ed25519 public key\n   */\n  toBytes(): Uint8Array {\n    return this.data\n  }\n\n  /**\n   * Return the Rooch address associated with this Ed25519 public key\n   */\n  flag(): number {\n    return SIGNATURE_SCHEME_TO_FLAG.ED25519\n  }\n\n  /**\n   * Verifies that the signature is valid for the provided message\n   */\n  async verify(message: Uint8Array, signature: Uint8Array): Promise<boolean> {\n    return nacl.sign.detached.verify(message, signature, this.toBytes())\n  }\n\n  /**\n   * Return the Rooch address associated with this Ed25519 public key\n   */\n  toAddress(): RoochAddress {\n    const tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1)\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG.ED25519])\n    tmp.set(this.toBytes(), 1)\n\n    // Each hex char represents half a byte, hence hex address doubles the length\n    return new RoochAddress(blake2b(tmp, { dkLen: 32 }).slice(0, ROOCH_ADDRESS_LENGTH * 2))\n  }\n}\n"],
  "mappings": "AAGA,OAAO,UAAU;AAEjB,SAAS,sBAAsB,oBAAoB;AAEnD,SAAS,WAAW,gCAAgC;AACpD,SAAS,SAAS,eAAe;AAEjC,MAAM,kBAAkB;AAKjB,MAAM,yBAAyB,UAAwB;AAAA;AAAA;AAAA;AAAA;AAAA,EAS5D,YAAY,OAA0B;AACpC,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC7B,WAAK,OAAO,QAAQ,KAAK;AAAA,IAC3B,WAAW,iBAAiB,YAAY;AACtC,WAAK,OAAO;AAAA,IACd,OAAO;AACL,WAAK,OAAO,WAAW,KAAK,KAAK;AAAA,IACnC;AAEA,QAAI,KAAK,KAAK,WAAW,iBAAiB;AACxC,YAAM,IAAI;AAAA,QACR,sCAAsC,8BAA8B,KAAK,KAAK;AAAA,MAChF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKS,OAAO,WAAsC;AACpD,WAAO,MAAM,OAAO,SAAS;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,UAAsB;AACpB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe;AACb,WAAO,yBAAyB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,SAAqB,WAAyC;AACzE,WAAO,KAAK,KAAK,SAAS,OAAO,SAAS,WAAW,KAAK,QAAQ,CAAC;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA,EAKA,YAA0B;AACxB,UAAM,MAAM,IAAI,WAAW,kBAAkB,CAAC;AAC9C,QAAI,IAAI,CAAC,yBAAyB,OAAO,CAAC;AAC1C,QAAI,IAAI,KAAK,QAAQ,GAAG,CAAC;AAGzB,WAAO,IAAI,aAAa,QAAQ,KAAK,EAAE,OAAO,GAAG,CAAC,EAAE,MAAM,GAAG,uBAAuB,CAAC,CAAC;AAAA,EACxF;AACF;AAlEa,iBACJ,OAAO;",
  "names": []
}
