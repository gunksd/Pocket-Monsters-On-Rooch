import { bcs } from "../bcs/index.js";
import { bytes, sha256, toHEX, concatBytes, varintByteNum } from "../utils/index.js";
import { SIGNATURE_SCHEME_TO_FLAG } from "./signatureScheme.js";
const BitcoinMessagePrefix = "Bitcoin Signed Message:\n";
const MessageInfoPrefix = "Rooch Transaction:\n";
class BitcoinSignMessage {
  constructor(txData, messageInfo) {
    this.messagePrefix = BitcoinMessagePrefix;
    let msg = messageInfo.startsWith(MessageInfoPrefix) ? messageInfo : MessageInfoPrefix + messageInfo;
    msg = msg.charAt(msg.length - 1) !== "\n" ? msg + "\n" : msg;
    this.messageInfo = msg;
    this.txHash = txData;
  }
  raw() {
    return this.messageInfo + toHEX(this.txHash);
  }
  encode() {
    const msgHex = bytes("utf8", toHEX(this.txHash));
    const infoBytes = bytes("utf8", this.messageInfo);
    const prefixBytes = concatBytes(
      bytes("utf8", this.messagePrefix),
      varintByteNum(infoBytes.length + msgHex.length)
    );
    const totalLength = prefixBytes.length + infoBytes.length + msgHex.length;
    const data = new Uint8Array(totalLength);
    let offset = 0;
    data.set(prefixBytes, offset);
    offset += prefixBytes.length;
    data.set(infoBytes, offset);
    offset += infoBytes.length;
    data.set(msgHex, offset);
    return data;
  }
  hash() {
    return sha256(this.encode());
  }
}
var BuiltinAuthValidator = /* @__PURE__ */ ((BuiltinAuthValidator2) => {
  BuiltinAuthValidator2[BuiltinAuthValidator2["ROOCH"] = 0] = "ROOCH";
  BuiltinAuthValidator2[BuiltinAuthValidator2["BITCOIN"] = 1] = "BITCOIN";
  return BuiltinAuthValidator2;
})(BuiltinAuthValidator || {});
class Authenticator {
  constructor(authValidatorId, payload) {
    this.authValidatorId = authValidatorId;
    this.payload = payload;
  }
  encode() {
    return bcs.Authenticator.serialize({
      authValidatorId: this.authValidatorId,
      payload: this.payload
    }).toBytes();
  }
  static async rooch(input, signer) {
    const signature = await signer.sign(input);
    const pubKeyBytes = signer.getPublicKey().toBytes();
    const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
    serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signer.getKeyScheme()]]);
    serializedSignature.set(signature, 1);
    serializedSignature.set(signer.getPublicKey().toBytes(), 1 + signature.length);
    return new Authenticator(0 /* ROOCH */, serializedSignature);
  }
  static async bitcoin(input, signer, signWith = "hash") {
    if (!input.messageInfo.startsWith(MessageInfoPrefix)) {
      throw Error("invalid message info");
    }
    const messageLength = bytes("utf8", input.messageInfo).length + toHEX(input.txHash).length;
    const sign = await signer.sign(signWith === "hash" ? input.hash() : bytes("utf8", input.raw()));
    const payload = bcs.BitcoinAuthPayload.serialize({
      signature: sign,
      messagePrefix: concatBytes(bytes("utf8", input.messagePrefix), varintByteNum(messageLength)),
      messageInfo: bytes("utf8", input.messageInfo),
      publicKey: signer.getPublicKey().toBytes(),
      fromAddress: bytes("utf8", signer.getBitcoinAddress().toStr())
    }).toBytes();
    return new Authenticator(1 /* BITCOIN */, payload);
  }
}
export {
  Authenticator,
  BitcoinSignMessage,
  BuiltinAuthValidator
};
//# sourceMappingURL=authenticator.js.map
